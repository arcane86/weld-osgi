<chapter>
    <title id="usages">How to make OSGi easy peasy</title>
    <section>
        <title>CDI usage in bean bundles</title>
        <para>Everything possible in CDI application is possible in bean bundle. They can take
            advantage of injection, producers, interceptors, decorators and alternative. But
            influence boundary of the CDI compliant container stay within the bean bundle for
            classic CDI usages. So external dependencies cannot be injected and interceptor,
            decorator or alternative of another bean bundle cannot be used (yet you still need to
            declare your own interceptors, decorators and alternatives in the bean bundle bean.xml
            file). </para>
        <para>That is all we will say about classic CDI usages, please report to CDI documentation
            for more information.</para>
    </section>
    <section>
        <title>Injecting easiness in OSGi world</title>
        <para>CDI-OSGi provides more functionality using CDI in a OSGi environment.</para>
        <para>It mainly focuses on the OSGi service layer. It addresses the difficulties in
            publishing and consuming services. CDI-OSGi allows developers to publish and consume
            OSGi services as CDI beans. However, since OSGi services are dynamic there are some
            differences with classic bean injection. This section presents how OSGi services can be
            published and consumed using CDI-OSGi.</para>
        <para>CDI-OSGi also provides utilities for event notification and communication in and
            between bundles as well as some general OSGi utilities.</para>
        <para>Examples use this very sophisticated service interface:
            <programlisting>public interface MyService {
    void doSomething();
}</programlisting></para>
        <section>
            <title>Service, implementation, instance and registration</title>
            <para>First it is important to be clear about what are a service, its implementations,
                its instances and its registration.</para>
            <para>A service is mostly an interface. This interface defines the contract that
                describes what the service may do. It might be several way to actually providing the
                service, thus a service might have multiple implementations.</para>
            <para>A service implementation is a class that implements this service. It is what is
                available to other components that use the service. To use the service the component
                obtain an instance of the implementation.</para>
            <para>A service instance is an instance of one of the service implementations. It is
                what the user manipulates to perform the service.</para>
            <para>A registration is the object that represents a service registered with a
                particular implementation. Then this implementation can be searched and its
                instances can be obtained. Every time a service implementation his register a
                corresponding registration object is created.</para>
        </section>
        <section>
            <title>OSGi services injection</title>
            <para> There are two ways to obtain a service instances using CDI-OSGi: direct injection
                and programmatic lookup.</para>
            <section>
                <title>Direct injection using <code>@OSGiService</code> annotation </title>
                <para>The main way to perform an OSGi injection is to use the <code>@Inject
                        @OSGiService</code> annotation combination. It acts like a common injection
                    except that CDI-OSGi will search for injectable instances in the service
                    registry.</para>
                <para>That is how it looks like:
                    <programlisting>@Inject @OSGiService MyService service;
service.doSomething(); </programlisting></para>
                <para>The behavior is similar with classic CDI injection. <code>@OSGiService</code>
                    is just a special qualifier that allows extension bundle to manage the injection
                    instead of implementation bundle.</para>
            </section>
            <section>
                <title>Injection using programmatic lookup</title>
                <para>TODO As in classic CDI injection you can obtain all the implementation of an
                    availables bean and then instantiate one at runtime. The interface
                        <code>Service&lt;T&gt;</code> allows the same thing with services. CDI-OSGi
                    will search for all injectable implementations in the service registry. </para>
                <para>Instead of obtain directly a service instance it is possible to choose between
                    service implementations and instanciate one at runtime. The interface
                        <code>Service&lt;T></code> works as a service instance producer: it
                    retreives all the coresponding (to the service parametrized type) service
                    implementations and allows to get an instances for each.</para>
                <para>Service implementations and a corresponding instance can be obtained like
                    that:
                    <programlisting>@Inject Service&lt;MyService> services;
services.get().doSomething();</programlisting>You
                    can also iterate over all implementations like that:
                    <programlisting>@Inject Service&lt;MyService> services;
for (MyService service : services) {
    service.get().doSomething();
}</programlisting>The
                        <code>get()</code> method returns a contextual instance of the
                    service.</para>
                <para><code>Service&lt;T></code> extends CDI <code>Instance&lt;T></code> so the
                    behavior is similar except that the injection process is managed by the
                    extension bundle instead of implementation bundle. So the available
                    implementations are searched dynanically into the service registry.</para>
            </section>
        </section>
        <section>
            <title>OSGi service automatic publishing with <code>@Publish</code> annotation </title>
            <para>CDI-OSGi allows developers to automatically publish service implementation. There
                is nothing to do, just put the annotation. OSGi framework is completely hidden. Then
                the service is accessible through CDI-OSGi service injection and OSGi classic
                mechanisms.</para>
            <para>Automatically publish a new service implementation:
                <programlisting>@Publish
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}</programlisting>It
                registers a service <code>MyService</code> with the implementation
                    <code>MyServiceImpl</code>.</para>
            <para>The behavior is similar with classic CDI bean declaration, except that services
                are not register into the bean manager but into the service registry like regular
                service registry.</para>
        </section>
        <section>
            <title>Clearly specify a service implementation</title>
            <para>There might be multiple implementations of the same service. It is possible to
                qualify specifities of an implementation in CDI-OSGi. This qualification is
                available both during publishing and consuming.</para>
            <para>There are two ways for qualifying: a CDI like and a OSGi like, both are presented
                below.</para>
            <section>
                <title>Using <code>@Qualifier</code> annotations</title>
                <para>Qualifiers are used like in classic CDI applications. An implementation can be
                    qualified by as many qualifiers as needed. An injection point can be also
                    qualified in order to restraint the potential injected implementations. It is
                    finally possible to select the instance produced when using the
                        <code>Service&lt;T></code> interface.</para>
                <para>Qualified service publishing:
                    <programlisting>
@Publish
@AnyQualifier
public class MyServiceQualifiedImpl implements MyService {

    @Override
    public void doSomething() {
    }
}                </programlisting>Qualified
                    injection point:
                    <programlisting>
@Inject @OSGiService @AnyQualifier MyService qualifiedService; 
qualifiedService.doSomething();</programlisting>Qualified
                    service producer:
                    <programlisting>
@Inject @AnyQualifier Service&lt;MyService> service;
service.get().doSomething();

@Inject Service&lt;MyService> services;
services.select(new AnnotationLiteral&lt;AnyQualifier>() {}).get().deSomething();</programlisting></para>
                <para>The qualifiers should be seen as the service properties. Here another example:
                    <programlisting>@Publish
@Lang(Languages.EN)
@Country(Countries.US)
@ApplicationScoped
public class MyServiceImpl implements MyService {

    @Override
    public void doSomething() {
    }
}

@Inject Service&lt;MyService> @Lang(Languages.EN) @Country(Countries.US) service;</programlisting></para>
                <para>The behavior is similar with classic CDI qualifiers. But there another
                    possibility in order to qualify a service.</para>
            </section>
            <section>
                <title>Filtering services</title>
                <para>Since CDI-OSGi services stay OSGi services they can be filtered through LDAP
                    filter. Properties might be added at publishing using the <code>Publish</code>
                    annotation values. Then an LDAP filter can be use at injection point using the
                        <code>Filter</code> annotation. </para>
                <para>An example is worth a thousand words:
                    <programlisting>@Publish({
    @Property(name="lang", value="EN"),
    @Property(name="country", value="US")
})
@ApplicationScoped
public class MyServiceImpl implements MyService {

    @Override
    public void doSomething() {
    }
}</programlisting>As
                    many <code>@Property</code> annotation as wanted can be added, they are
                    registered with the service implementation.</para>
                <para>Then it is possible to filter an injection point with the <code>Filter</code>
                    annotation like a regular LDAP filter:
                    <programlisting>@Inject Service&lt;MyService> @Filter("(&amp;(lang=*)(country=US))") service;</programlisting></para>
            </section>
            <section>
                <title>Links between qualifier annotations and LDAP filtering</title>
                <para>TODO Is @AnyQualifier similar with @Property(name="anyqualifier", value="") ?
                    And is @Property(name="anyqualifier", value="anyValue") similar with
                    @AnyQualifier("anyValue") ? To any qualifier correspond a generated filter ? To
                    any filter correpond an implicit qualifier (oO even possible ?) ?</para>
                <para>Consider this code, will it work ? (it'll be cool!
                    )<programlisting>@Publish
@Lang(Languages.EN)
@Country(Countries.US)
@ApplicationScoped
public class MyServiceImpl implements MyService {

    @Override
    public void doSomething() {
    }
}

@Inject Service&lt;MyService> @Filter("(&amp;(lang=*)(country=US))") service;</programlisting></para>
                <para>And this
                    ?<programlisting>@Publish({
    @Property(name="lang", value="EN"),
    @Property(name="country", value="US")
})
@ApplicationScoped
public class MyServiceImpl implements MyService {

    @Override
    public void doSomething() {
    }
}

@Inject Service&lt;MyService> @Lang(Languages.EN) @Country(Countries.US) service;</programlisting></para>
            </section>
        </section>
        <section>
            <title>Contextual services</title>
            <para>Like for bean instances, service instances are contextual. Every implementation is
                bounded to a particular scope. Provided that an satisfactory implementation is
                available, a service injection will return a contextual instance of the
                implementation.</para>
            <para>All CDI scopes are available for CDI-OSGi services and their use is the same:
                <programlisting>@Publish
@ApplicationScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}</programlisting>A
                instance will be shared by the entire
                application.<programlisting>@Publish
@RequestScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}                </programlisting>A
                new instance is created for every request. </para>
        </section>
        <section>
            <title>The registration</title>
            <para>TODO</para>
        </section>
        <section>
            <title>Service registry</title>
            <para>CDI-OSGi offers another way to deal with services: the service registry. It can be
                obtained in any bundle as a regular service, using OSGi or CDI-OSGi ways. The
                service registry allows developers to dynamically register service implementation,
                to obtain services and registrations.</para>
            <section>
                <title>First get the service registry</title>
                <para>TODO Is the service registry a bean or a service ? If it is a service it could
                    use by regular bundle, couldn't it ?</para>
                <para>First get the service registry:
                    <programlisting>@Inject @OSGiService ServiceRegistry registry;</programlisting>Or
                    in regular bundle:
                    <programlisting>ServiceReference reference = bundleContext.getServiceReference(ServiceRegistry.class.getName());
ServiceRegistry registry = (ServiceRegistry) bundleContext.getService(reference);</programlisting></para>
            </section>
            <section>
                <title>Register a service implementation</title>
                <para>Register a service implementation:
                    <programlisting>registry.registerService(MyService.class,MyServiceImpl.class);</programlisting>
                    or
                    <programlisting>@Inject MyServiceImpl implementation;
registry.registerService(MyService.class,implementation);</programlisting>Here
                    the scope of the service is ??? (Dependent ?)</para>
                <para>It is possible to collect the corresponding registration:
                    <programlisting>Registration&lt;MyService> registeredService = registry.registerService(MyService.class,MyServiceImpl.class);</programlisting></para>
            </section>
            <section>
                <title>Obtain a service implementations</title>
                <para>Obtain a service implementations:
                    <programlisting>Service&lt;MyService> services = registry.getServiceReference(MyService.class);
for (MyService service : services) {
    service.doSomething();
}</programlisting></para>
            </section>
            <section>
                <title>Obtain registrations and unresister service implementation</title>
                <para>Obtain all registrations or registration of a filtered or not filtered
                    specified service:
                    <programlisting>Registrations&lt;?> registrations = registry.getRegistrations();
Registrations&lt;MyService> myRegistrations = registry.getRegistrations(MyService.class);
Registrations&lt;MyService> myFrenchRegistrations = registry.getRegistrations(MyService.class,"(lang=FR)");</programlisting>Unregister
                    a service implementation:
                    <programlisting>for(Registration registration : registrations) {
    registration.unregister()
}           </programlisting></para>
            </section>
        </section>
        <section>
            <title>Distinctions between CDI-OSGi service injection and CDI bean injection</title>
            <para>All the way it is said that CDI-OSGi service injection is similar with classic CDI
                bean injection. That is true, but there some important distinctions to make. CDI
                users will quickly find their bearings in CDI-OSGi and that is the point because CDI
                way is much simplier that OSGi mechanisms (so CDI-OSGi is also a good thing for
                newcomers in both CDI and OSGi worlds! ).</para>
            <para>The main difference is about the dynamism of OSGi services. While a bean injection
                point should be satisfy at the start of the CDI container, service injection may be
                satisfy only at runtime.</para>
            <para>So what ? TODO Ambigous and unsatisfied dependency managment and other stuffs that
                vary from classic CDI.</para>
            <section>
                <title>The <code>OSGiServiceUnavailableException</code> exception </title>
                <para>Because OSGi service are dynamic they might be unavailable at the time they
                    should be used. On a service call if the targeted service isn't available a
                    specific runtime exception is raised:
                    <programlisting>public class OSGiServiceUnavailableException extends RuntimeException {}</programlisting></para>
            </section>
            <section>
                <title>And everything else ?</title>
                <para>If it is not indicated otherwhise assume that the compotment is the same as
                    CDI or OSGi without CDI-OSGi.</para>
            </section>
        </section>
    </section>
    <section>
        <title>CDI-OSGi events</title>
        <para> TODO</para>
        <section>
            <title>TODO</title>
            <para>TODO</para>
        </section>
    </section>
    <section>
        <title>OSGi utilities</title>
        <para>

        </para>
    </section>
    <section>
        <title>CDI-OSGi, what else ?</title>
        <para>Here there are some examples that concretely show what CDI-OSGi is avoiding to the
            developer:</para>
        <section>
            <title>Simple service injection</title>
            <para>CDI-OSGi:<programlisting>@Inject @OSGiService ServiceRegistry registry;</programlisting>versus
                classic
                OSGi:<programlisting>ServiceReference reference = bundleContext.getServiceReference(ServiceRegistry.class.getName());
ServiceRegistry registry = (ServiceRegistry) bundleContext.getService(reference);</programlisting></para>
        </section>
        <section>
            <title>TODO other example</title>
            <para>TODO</para>
        </section>
    </section>
</chapter>
