<chapter>
    <title id="osgicdipresentation">Organization of OSGi-CDI</title>
    <section>
        <title>APIs and infrastructure bundle</title>
        <para>
            OSGi-CDI is composed of two bundles. One provides the APIs used to define utilities provided and hooking
            up
            system with CDI container, the other the implementation et CDI management over OSGi environment.
        </para>
        <para>
            The APIs bundle exposed all packages that could be needed by developers; both for client application
            using
            OSGi-CDI and for CDI compliant container integration. These two sides are presented in the next sections.
        </para>
        <para>
            The infrastructure bundle is the orchestrator of OSGi-CDI. It may be use by any application that require
            OSGi-CDI. It runs in shadow using a CDI compliant container. This bundle is presented at the end of this
            section.
        </para>
        <section>
            <title>Extention API versus integration API</title>
            <para>
                OSGi-CDI APIs bundle provides two distinct APIs:
                <itemizedlist>
                    <listitem>
                        <para>
                            The extension API that describes all the new functionality provided by OSGi-CDI in the
                            OSGi
                            environment.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The integration API that allows CDI compliant container to be used with OSGi-CDI.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                These two APIs are more described below.
            </para>
            <section>
                <title>Extension API</title>
                <para>
                    The extension API defines all the utilities provided to OSGi environment using CDI specification.
                    It exposes all the new utilities and defines the comportment of the infrastructure bundle.
                </para>
                <para>
                    It exposes all the interfaces, events and annotations usable by a developers in order to realize
                    its
                    client bean bundle. It defines the programming model of OSGi-CDI client bundle. Mostly it is
                    about
                    publishing and consuming injectable services in a CDI way to do.
                </para>
                <para>
                    It also describes the object the infrastructure bundle needs to orchestrate bean bundles.
                </para>
                <para>
                    So this where to search for the new usages you could do of OSGi.
                </para>
            </section>
            <section>
                <title>Integration API</title>
                <para>
                    The integration API defines how a CDI container, such as Weld, should bootstrap with the CDI OSGi
                    extension. So any CDI environment implementation could use the CDI OSGi extension transparently.
                </para>
                <para>
                    This aims at providing the minimum integration in order to start a CDI compliant container with
                    every
                    managed bean bundle. Then the infrastructure bundle can get a CDI container to provide to every
                    one
                    of
                    its manages bean bundle.
                </para>
                <para>
                    Moreover the integration API allows to mix CDI compliant container in the same application by
                    providing
                    a embedded mode. In this mode a bean bundle is decoupled from the infrastructure bundle and is
                    managed
                    on its own. Thus you can use various implementations of CDI container or particularize the
                    behavior

                    of a
                    particular bean bundle.
                </para>
                <para>
                    All this bootstrapping mechanism works using the service layer of OSGi. A CDI compliant container
                    bundle may provide a service that allows the infrastructure bundle to obtain a new container for
                    every bean bundle.
                </para>
                <para>
                    So this where to search to make OSGi-CDI use your CDI compliant container.
                </para>
            </section>
        </section>
        <section>
            <title>Infrastructure bundle : the puppet master</title>
            <para>
                The infrastructure bundle is the heart of OSGi-CDI application. Once it is started, providing that it
                finds a CDI compliant container to use, it manages all the bean bundle. It is in charge of
                inter-bundle
                injection, service injection, OSGi to CDI and inter-bundle communications.
            </para>
            <para>
                It is a worker in the shadow, it just need to be started at the beginning of the application, then
                everything is transparent the user. Client bundles do not have to do anything in order to use
                OSGi-CDI
                functionality. They just use CDI injection and service injection.
            </para>
            <para>
                In order to perform injections the infrastructure bundle search for a CDI compliant container service
                provider
                once it is started. Thus it can only work coupled with a bundle providing such a service.
            </para>
            <para>
                So this is where the magic happens and where your OSGi application become much more simple.
            </para>
        </section>
        <para>
            The next sections explain in details the capacity of these three artifacts.
        </para>
    </section>
    <section>
        <title>An OSGi extension for CDI support</title>
        <section>
            <title>The extender pattern</title>
            <para>
                OSGi-CDI provides an extension to OSGi as an extender OSGi pattern. The infrastructure bundle, the
                extender, tracks for bean bundles, the extensions, to be started. Then CDI utilities are enabled for
                these bean bundles over OSGi environment.
            </para>
        </section>
        <section>
            <title>The Java extension mechanism</title>
            <para>
                TODO
            </para>
        </section>
        <section>
            <title>OSGi-CDI provides these features :</title>
            <para>
                TO REDO
                <itemizedlist>
                    <listitem>
                        <para>
                            Global management using extender pattern with a
                            infra
                            bundle providing features to the entire application
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Embedded modes to manage your own bundles, with
                            various
                            control policies, in classic OSGi application
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Full annotation configuration following CDI model
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Intra bundle CDI full support: injection, producers,
                            interceptors, decorators ...
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Services injection, with full support of
                            requirement,
                            ldap filtering and OSGi dynamism
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Automatic services publication fully compatible with
                            OSGi
                            service registering system
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Support for OSGi specific injection (such as bundle

                            or
                            manifest headers
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Event notification and inter bundles communication
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                We will see in the next sections these features in deep.
            </para>
        </section>
        <section>
            <title>The interfaces</title>
            <para>
                
            </para>
        <section>
            <title>The <code>Service</code> and <code>Services</code> interfaces</title>
            <para>

            </para>
        </section>
        <section>
            <title>The <code>Registration</code> and <code>Registrations</code> interfaces</title>
            <para>

            </para>
        </section>
        <section>
            <title>The <code>ServiceRegistry</code> interface</title>
            <para>

            </para>
        </section>
        <section>
            <title>The <code>BundleContainer</code> and <code>BundleContainers</code> interfaces</title>
            <para>
                
            </para>
        </section>
        </section>
        <section>
            <title>The events</title>
            <para>
                
            </para>
        <section>
            <title>The <code>BundleContainerInitialized</code> and <code>BundleContainerShutDown</code> events</title>
            <para>

            </para>
        </section>
        <section>
            <title>The <code>BundleEvents</code> events</title>
            <para>

            </para>
        </section>
        <section>
            <title>The <code>ServiceArrival</code>, <code>ServiceChanged</code> and <code>ServiceDeparture</code> events</title>
            <para>

            </para>
        </section>
        <section>
            <title>The <code>AbstractBundleEvent</code> and <code>AbstractServiceEvent</code> events</title>
            <para>

            </para>
        </section>
        <section>
            <title>The <code>Valid</code> and <code>Invalid</code> events</title>
            <para>

            </para>
        </section>
        </section>
        <section>
            <title>The annotations</title>
            <para>

            </para>
            <section>
                <title>TO BE CONTINUED</title>
            </section>
        </section>
    </section>
    <section>
        <title>A standard bootstrap API for CDI container integration</title>
        <section>
            <title>Intergration API</title>
            <para>
                TODO
            </para>
        </section>
        <section>
            <title>Embedded mode</title>
            <para>
                TODO
            </para>
        </section>
    </section>
    <section>
        <title>A orchestrator : the infrastructure bundle</title>
        <para>

        </para>
        <section>
            <title>The infrastructure bundle works that way:</title>
            <para>
                <programlisting>
                    BEGIN
                    start
                    WHILE ! container_bundle.isStarted
                    wait
                    END_WHILE
                    obtain_container
                    FOR bean_bundle : started_bundles
                    manage_bean_bundle
                    provide_container
                    END_FOR
                    WHILE container_bundle.isStarted
                    wait_event
                    OnBeanBundleStart
                    manage_bean_bundle
                    provide_container
                    OnBeanBundleStop
                    unmanage_bean_bundle
                    END_WHILE
                    stop
                    FOR bean_bundle : namaged_bundles
                    unmanage_bean_bundle
                    stop_bean_bundle
                    END_FOR
                    END
                </programlisting>
            </para>
        </section>
        <section>
            <title>A container bundle may work that way:</title>
            <para>
                <programlisting>
                    HOW DO I WORK ?
                </programlisting>
            </para>
        </section>
    </section>

    <section>
        <title>How to make a bundle or a bean archive a bean bundle</title>
        <para>
            There are very few things to do in order to obtain a bean bundle from a bean archive or a bundle. Mostly
            you should just add the missing marker file in the archive:
        </para>
        <para>
            <itemizedlist>
                <listitem>
                    <para>
                        Take your bean archive and make it a bean bundle by adding a
                        <code>META-INF/Manifest.MF</code>
                        file.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Or, in the other way, take your bundle and make it a bean bundle by adding a
                        <code>META-INF/bean.xml</code>
                        file.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            However there is a few other information that Weld-OSGi might need in order to perform a correct
            extension.
            In particular you might want a bean bundle to be not manage by the infrastructure bundle but by his own
            embedded CDI container. For that there is a new manifest header.
        </para>
        <section>
            <title>The
                <code>META-INF/bean.xml</code>
                file
            </title>
            <para>
                The beans.xml file follows no particular rules and should be the same as in a native CDI environment.
                Thus it can be completely empty or declare interceptors, decorators or alternatives as a regular CDI
                beans.xml file.
            </para>
            <para>
                There will be no different behavior with a classic bean archive except for CDI OSGi extension new
                utilities. But these don't need any modification on the
                <code>META-INF/bean.xml</code>
                file.
            </para>
        </section>
        <section>
            <title>The Embedded-CDIContainer
                <code>META-INF/Manifest.MF</code>
                header
            </title>
            <para>
                This header prevents the infrastructure bundle to automatically manage the bean bundle that set this
                manifest header to true. So the bean bundle can be manage more finely by the user or use a different
                CDI
                container. If this header is set to false or is not present in the
                <code>META-INF/Manifest.MF</code>
                file then the bean bundle will be automatically manage by the infrastructure bundle (if it is started).
            </para>
        </section>
    </section>
</chapter>