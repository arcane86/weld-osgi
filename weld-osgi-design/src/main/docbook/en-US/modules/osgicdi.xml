<chapter>
    <title id="osgicdipresentation">Organization of CDI-OSGi</title>
    <section>
        <title>APIs bundle, extension bundle and implementation bundle</title>
        <para>CDI-OSGi is composed of three bundles: <itemizedlist>
                <listitem>
                    <para>The APIs bundle that provides the APIs used to define both utilities
                        provided and hooking up system with implementation bundle,</para>
                </listitem>
                <listitem>
                    <para>The extension bundle that provides CDI-OSGi functionalities for bean
                        bundles by managing them,</para>
                </listitem>
                <listitem>
                    <para>An implementation bundle provides CDI functionalities usable by the
                        extension bundle through an OSGi service.</para>
                </listitem>
            </itemizedlist></para>
        <section>
            <title>Extention API versus integration API</title>
            <para>The APIs bundle exposed all packages that could be needed by developers; both for
                client application using CDI-OSGi and for CDI compliant container integration. It
                may be use as a dependency for bean bundles, extension bundle and implementation
                bundle.</para>
            <para>CDI-OSGi APIs bundle provides two distinct APIs: <itemizedlist>
                    <listitem>
                        <para> The extension API that describes all the new functionality provided
                            by CDI-OSGi in the OSGi environment. </para>
                    </listitem>
                    <listitem>
                        <para> The integration API that allows CDI compliant container to be used
                            with CDI-OSGi. </para>
                    </listitem>
                </itemizedlist></para>
            <para>These two APIs are more described below.</para>
            <section>
                <title>Extension API</title>
                <para>The extension API defines all the utilities provided to OSGi environment using
                    CDI specification. It exposes all the new utilities and defines the comportment
                    of the extension bundle.</para>
                <para>It exposes all the interfaces, events and annotations usable by a developers
                    in order to realize its client bean bundle. It defines the programming model of
                    CDI-OSGi client bundle. Mostly it is about publishing and consuming injectable
                    services in a CDI way.</para>
                <para>It also describes the object the extension bundle needs to orchestrate bean
                    bundles.</para>
                <para>So this is where to search for new usages of OSGi.</para>
            </section>
            <section>
                <title>Integration API</title>
                <para>The integration API defines how a CDI container, such as Weld, should
                    bootstrap with the CDI OSGi extension. So any CDI environment implementation
                    could use the CDI OSGi extension transparently. The CDI compliant container may
                    be provided using an implementation bundle.</para>
                <para>This aims at providing the minimum integration in order to start a CDI
                    compliant container with every managed bean bundle. Then the extension bundle
                    can get a CDI container to provide to every one of its manages bean
                    bundle.</para>
                <para>Moreover the integration API allows to mix CDI compliant container in the same
                    application by providing an embedded mode. In this mode a bean bundle is
                    decoupled from the extension bundle and is managed on its own. Thus various
                    implementations of CDI container can be used or the behavior of a particular
                    bean bundle can be particularized.</para>
                <para>All this bootstrapping mechanism works using the service layer of OSGi. A CDI
                    compliant implementation bundle may provide a service that allows the extension
                    bundle to obtain a new container for every bean bundle.</para>
                <para>So this is where to search to make CDI-OSGi use a specific CDI compliant
                    container.</para>
            </section>
        </section>
        <section>
            <title>Extension bundle: the puppet master</title>
            <para>The extension bundle is the orchestrator of CDI-OSGi. It may be use by any
                application that requires CDI-OSGi. It may be just started at the begining of a
                CDI-OSGi application. It requests the APIs bundle as a dependency.</para>
            <para>The extension bundle is the heart of CDI-OSGi application. Once it is started,
                provided that it finds a started implementation bundle, it manages all the bean
                bundles. It is in charge of service automatic publishings, service injections, CDI
                event notifications and bundle communications.</para>
            <para>It runs in background, it just need to be started at the beginning of the
                application, then everything is transparent to the user. Client bean bundles do not
                have to do anything in order to use CDI-OSGi functionality.</para>
            <para>In order to perform injections the extension bundle search for a CDI compliant
                container service provider once it is started. Thus it can only work coupled with a
                bundle providing such a service: an implementation bundle.</para>
            <para>So this is where the magic happens and where OSGi applications become much more
                simple.</para>
        </section>
        <section>
            <title>Implementation bundle: choose a CDI compliant container</title>
            <para>The implementation bundle is responsible for providing CDI compliant containers to
                the extension bundle. It may be started with the extension bundle and publish the
                right service. It request the APIs bundle as a dependency.</para>
            <para>It is an implementation of the integration API, thus it may provide a CDI
                container factory service.</para>
        </section>
        <section>
            <title>CDI-OSGi bundles organization diagram</title>
            <figure>
                <title>CDI-OSGI bundles organization</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/CDI-OSGicoreorganization.png"
                            contentwidth="800" align="center"/>
                    </imageobject>
                    <caption>This diagram represents the internal organization of CDI-OSGi bundles.
                        The coupling between the three bundles is represented as well as what is
                        exposed to bean bundles.</caption>
                </mediaobject>
            </figure>
            <para>The diagram above shows how CDI-OSGi bundles are linked together. The blue part is
                the core of OSGi and is provided. The red part is a required but interchangeable
                bundle.</para>
            <para>All together these three bundle make CDI-OSGi. Then CDI-OSGi functionalities are
                exposed to bean bundles and an OSGi extension is provided in order to manage these
                bean bundles.</para>
        </section>
    </section>
    <section>
        <title>An OSGi extension for CDI support: the extension API</title>
        <section>
            <title>The extender pattern</title>
            <para>CDI-OSGi provides an extension to OSGi as an extender OSGi pattern. The extension
                bundle, the extender, tracks for bean bundles, the extensions, to be started. Then
                CDI utilities are enabled for these bean bundles over OSGi environment.</para>
        </section>
        <section>
            <title>CDI-OSGi features</title>
            <para>As an extension to OSGi, CDI-OSGi provides several features : <itemizedlist>
                    <listitem>
                        <para> Complete integration in OSGi world by the use of extender pattern and
                            extension bundle. Thus complete compatibility with already existing
                            tools.</para>
                    </listitem>
                    <listitem>
                        <para> Non intruding, configurable and customizable behavior in new or
                            upgraded application. Simple configuration and usage using annotation,
                            completely xml free.</para>
                    </listitem>
                    <listitem>
                        <para> Full internal CDI support for bean bundles: injection, producers,
                            interceptors, decorators ...</para>
                    </listitem>
                    <listitem>
                        <para> Lot of ease features for OSGi usages: injectable services, event
                            notifications, inter-bundle communication ...</para>
                    </listitem>
                    <listitem>
                        <para> OSGi and CDI compliance all along the way ensuring compatibility with
                            all CDI compliant container and easy application realisation or
                            portage.</para>
                    </listitem>
                </itemizedlist></para>
            <para>We will see in the next sections these features in deep through the description of
                the extension API.</para>
        </section>
        <section>
            <title>The interfaces</title>
            <para>Extension API provides few interfaces that describe all specifics about OSGi
                service injection.</para>
            <section>
                <title>The <code>Service</code> interface</title>
                <programlisting>public interface Service&lt;T&gt; extends Instance&lt;T&gt; {
    int size();
}</programlisting>
                <para>It represents a service producer parametrized by the service to inject. It has
                    the same behavior than CDI <code>Instance&lt;T></code> except that it represents
                    only OSGi service beans.</para>
            </section>
            <section>
                <title>The <code>Registration</code> interface</title>
                <programlisting>public interface Registration&lt;T> extends Iterable&lt;Registration&lt;T>> {

    void unregister();
    &lt;T> Service&lt;T> getServiceReference();
    int size();
}
            </programlisting>
                <para>This interface represents the registrations of a injectable OSGi services in
                    the service resgistry. It permits to act on previously registered services. Its
                    fonctionnement is similar to <code>Service&lt;T></code>, thus it might represent
                    the iterable set of all the registration of a service. It allows to select a
                    particular subset of registrations, to enregister service implementation or to
                    obtain a corresponding service reference.</para>
            </section>
            <section>
                <title>The <code>RegistrationHolder</code> interface</title>
                <para>
                    <programlisting>public interface RegistrationHolder {

    List&lt;ServiceRegistration> getRegistrations();
    void addRegistration(ServiceRegistration reg);
    void removeRegistration(ServiceRegistration reg);
    void clear();
    int size();
}</programlisting>
                </para>
                <para>This interface wraps the OSGi <code>ServiceRegistration</code>s in order to be
                    used by CDI-OSGi <code>Registration</code>. It provides utilitary methods to
                    handle the registration list of a given service.</para>
            </section>
            <section>
                <title>The <code>ServiceRegistry</code> interface</title>
                <programlisting>public interface ServiceRegistry {

    &lt;T> Registration&lt;T> registerService(Class&lt;T> contract, Class&lt;? extends T> implementation);
    &lt;T, U extends T> Registration&lt;T> registerService(Class&lt;T> contract, U implementation);
    &lt;T> Service&lt;T> getServiceReferences(Class&lt;T> contract);
    &lt;T> Service&lt;T> getServiceReference(Class&lt;T> contract);
    &lt;T> Provider&lt;T> newTypeInstance(Class&lt;T> unmanagedType);
}</programlisting>
                <para>This is where the injectable services may be registered and retrieved. It
                    allows to register services with their interface and implementation, getting
                    back the corespondent <code>Registration&lt;T></code> , to obtain the
                        <code>Service&lt;T></code> object corresponding to an service interface or
                    to obtain a producer object of an unmanaged type. </para>
            </section>
        </section>
        <section>
            <title>The events</title>
            <para>Extension API provides numerous events that notify about new life-cycle steps for
                container management, service injection management and communication between bean
                bundles. They all use CDI event system.</para>
            <section>
                <title>The <code>BundleContainerInitialized</code> and
                        <code>BundleContainerShutDown</code> events</title>
                <programlisting>public class BundleContainerInitialized {

    private BundleContext bundleContext;
    
    public BundleContainerInitialized(final BundleContext context) {
        this.bundleContext = context;
    }

    public BundleContext getBundleContext() {
        return bundleContext;
    }
}</programlisting>
                <programlisting>public class BundleContainerShutdown {

    private BundleContext bundleContext;

    public BundleContainerShutdown(final BundleContext context) {
        this.bundleContext = context;
    }

    public BundleContext getBundleContext() {
        return bundleContext;
    }
}</programlisting>
                <para>These two events advise about the state of bean bundles CDI compliant
                    container. They are fired respectively when a container has finished its
                    initialization and when a container begin to shutdown. They expose the
                    coresponding bean bundle <code>BundleContext</code>.</para>
            </section>
            <section>
                <title>The <code>AbstractBundleEvent</code> and <code>AbstractServiceEvent</code>
                    events</title>
                <programlisting>public abstract class AbstractBundleEvent {
                
    public static enum EventType {
        INSTALLED,LAZY_ACTIVATION,RESOLVED,STARTED,STARTING,
        STOPPED,STOPPING,UNINSTALLED,UNRESOLVED,UPDATED,
    }

    private final Bundle bundle;

    public AbstractBundleEvent(Bundle bundle) {
        this.bundle = bundle;
    }

    public abstract EventType getType();

    public long getBundleId() {
        return bundle.getBundleId();
    }

    public String getSymbolicName() {
        return bundle.getSymbolicName();
    }

    public Version getVersion() {
        return bundle.getVersion();
    }

    public Bundle getBundle() {
        return bundle;
    }
}</programlisting>
                <programlisting>public abstract class AbstractServiceEvent {

    public static enum EventType {
        SERVICE_ARRIVAL, SERVICE_DEPARTURE, SERVICE_CHANGED
    }

    private final ServiceReference ref;
    private final BundleContext context;
    private List&lt;String&gt; classesNames;
    private List&lt;Class&lt;?&gt;&gt; classes;
    private Map&lt;Class, Boolean&gt; assignable = new HashMap&lt;Class, Boolean&gt;();

    public AbstractServiceEvent(
        ServiceReference ref, BundleContext context) {
        this.ref = ref;
        this.context = context;
    }

    public abstract EventType eventType();

    public ServiceReference getRef() {
        return ref;
    }

    public &lt;T> TypedService&lt;T> type(Class&lt;T> type) {
        if (isTyped(type)) {
            return TypedService.create(type, context, ref);
        } else {
            throw new RuntimeException("the type " + type
                + " isn't supported for the service. Supported types are "
                + getServiceClasses());
        }
    }

    public Object getService() {
        return context.getService(ref);
    }

    public boolean ungetService() {
        return context.ungetService(ref);
    }

    public boolean isTyped(Class&lt;?> type) {
        boolean typed = false;
        if (!assignable.containsKey(type)) {
            for (Class clazz : getServiceClasses()) {
                if (type.isAssignableFrom(clazz)) {
                    typed = true;
                    break;
                }
            }
            assignable.put(type, typed);
        }
        return assignable.get(type);
    }

    public Bundle getRegisteringBundle() {
        return ref.getBundle();
    }

    public List&lt;String> getServiceClassNames() {
        if (classesNames == null) {
            classesNames = Arrays.asList((String[])
            ref.getProperty(Constants.OBJECTCLASS));
        }
        return classesNames;
    }

    public List&lt;Class&lt;?>> getServiceClasses() {
        if (classes == null) {
            classes = new ArrayList&lt;Class&lt;?&gt;&gt;();
            for (String className : getServiceClassNames()) {
                try {
                    classes.add(getClass().getClassLoader().loadClass(className));
                } catch (ClassNotFoundException ex) {
                return null;
                }
            }
        }
        return classes;
    }

    public static class TypedService&lt;T> {

        private final BundleContext context;
        private final ServiceReference ref;
        private final Class&lt;T> type;

        TypedService(BundleContext context, ServiceReference ref, Class&lt;T> type) {
            this.context = context;
            this.ref = ref;
            this.type = type;
        }

        static &lt;T> TypedService&lt;T> create(Class&lt;T> type, BundleContext context, ServiceReference ref) {
            return new TypedService&lt;T>(context, ref, type);
        }

        public T getService() {
            return type.cast(context.getService(ref));
        }

        public boolean ungetService() {
            return context.ungetService(ref);
        }
    }
}</programlisting>
                <para>These two abstract classes represent the information that bundle and service
                    events may carry when they are fired. They also allows to listen for all bundle
                    or service events in one operation.</para>
            </section>
            <section>
                <title>The <code>BundleEvents</code> events</title>
                <para>It regroups all the events about bundle life-cycle.</para>
                <programlisting>public class BundleEvents {

    public static class BundleInstalled extends AbstractBundleEvent {
        ...
    }

    public static class BundleLazyActivation extends AbstractBundleEvent {
        ...
    }

    public static class BundleResolved extends AbstractBundleEvent {
        ...
    }

    public static class BundleStarted extends AbstractBundleEvent {
        ...
    }

    public static class BundleStarting extends AbstractBundleEvent {
        ...
    }

    public static class BundleStopped extends AbstractBundleEvent {
        ...
    }

    public static class BundleStopping extends AbstractBundleEvent {
        ...
    }

    public static class BundleUninstalled extends AbstractBundleEvent {
        ...
    }

    public static class BundleUnresolved extends AbstractBundleEvent {
        ...
    }

    public static class BundleUpdated extends AbstractBundleEvent {
        ...
    }
}</programlisting>
                <programlisting>public static class BundleInstalled extends AbstractBundleEvent {

    public BundleInstalled(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.INSTALLED;
    }
}</programlisting>
                <programlisting>public static class BundleLazyActivation extends AbstractBundleEvent {

    public BundleLazyActivation(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.LAZY_ACTIVATION;
    }
}</programlisting>
                <programlisting>public static class BundleResolved extends AbstractBundleEvent {

    public BundleResolved(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.RESOLVED;
    }
}</programlisting>
                <programlisting>public static class BundleStarted extends AbstractBundleEvent {

    public BundleStarted(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.STARTED;
    }
}</programlisting>
                <programlisting>public static class BundleStarting extends AbstractBundleEvent {

    public BundleStarting(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.STARTING;
    }
}</programlisting>
                <programlisting>public static class BundleStopped extends AbstractBundleEvent {

    public BundleStopped(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.STOPPED;
    }
}</programlisting>
                <programlisting>public static class BundleStopping extends AbstractBundleEvent {

    public BundleStopping(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.STOPPING;
    }
}</programlisting>
                <programlisting>public static class BundleUninstalled extends AbstractBundleEvent {

    public BundleUninstalled(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.UNINSTALLED;
    }
}            </programlisting>
                <programlisting>public static class BundleUnresolved extends AbstractBundleEvent {

    public BundleUnresolved(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.UNRESOLVED;
    }
}            </programlisting>
                <programlisting>public static class BundleUpdated extends AbstractBundleEvent {

    public BundleUpdated(Bundle bundle) {
        super(bundle);
    }

    @Override
    public EventType getType() {
        return EventType.UPDATED;
    }
}</programlisting>
                <para>These events are automatically fired by CDI-OSGi and transmitted to other
                    bundles when the corresponding life-cycle step occurs in a bean bundle.</para>
            </section>
            <section>
                <title>The <code>ServiceArrival</code>, <code>ServiceChanged</code> and
                        <code>ServiceDeparture</code> events</title>
                <programlisting>public class ServiceArrival extends AbstractServiceEvent {

    public ServiceArrival(ServiceReference ref, BundleContext context) {
        super(ref, context);
    }

    @Override
    public EventType eventType() {
        return EventType.SERVICE_ARRIVAL;
    }
}</programlisting>
                <programlisting>public class ServiceChanged extends AbstractServiceEvent {

    public ServiceChanged(ServiceReference ref, BundleContext context) {
        super(ref, context);
    }

    @Override
    public EventType eventType() {
        return EventType.SERVICE_CHANGED;
    }
}</programlisting>
                <programlisting>public class ServiceDeparture extends AbstractServiceEvent {

    public ServiceDeparture(ServiceReference ref, BundleContext context) {
        super(ref, context);
    }

    @Override
    public EventType eventType() {
        return EventType.SERVICE_DEPARTURE;
    }
}</programlisting>
                <para>These events are automatically fired by CDI-OSGi and transmitted to other
                    bundles when the corresponding life-cycle step occurs in a OSGi service.</para>
            </section>
            <section>
                <title>The <code>Valid</code> and <code>Invalid</code> events</title>
                <programlisting>public class Valid {
}</programlisting>
                <programlisting>public class Invalid {
}</programlisting>
                <para>These two events notify about the state of bean bundles dependency resolution.
                    They are automatically fired by CDI-OSGi when all required service are available
                    or when at least one required service is unavailable.</para>
            </section>
        </section>
        <section>
            <title>The annotations</title>
            <para>Extension API provides annotations in order to easily use CDI-OSGi
                features.</para>
            <section>
                <title>The <code>OSGiBundle</code> annotation</title>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface OSGiBundle {
    @Nonbinding String value();
    @Nonbinding String version() default "";
}</programlisting>
                <para>This annotation qualifies an injection point that represents a bundle.</para>
            </section>
            <section>
                <title>The <code>BundleDataFile</code>, <code>BundleHeader</code>,
                        <code>BundleHeaders</code>, <code> BundleName</code> and
                        <code>BundleVersion</code> annotations</title>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleDataFile {
    @Nonbinding String value();
}</programlisting>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleHeader {
    @Nonbinding String value();
}</programlisting>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleHeaders {
}</programlisting>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleName {
    String value();
}</programlisting>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleVersion {
    String value();
}</programlisting>
                <para>These annotations qualify an injection point that represents bundle relative
                    information.</para>
            </section>
            <section>
                <title>The <code>OSGiService</code> annotation</title>
                <programlisting>@Qualifier
@Target({ TYPE, METHOD, PARAMETER, FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface OSGiService {
}</programlisting>
                <para>This annotation qualifies an injection point that represents a service in the
                    OSGi service registry.</para>
            </section>
            <section>
                <title>The <code>Publish</code> annotation</title>
                <programlisting>@Target({ TYPE })
@Retention(RetentionPolicy.RUNTIME)
public @interface Publish {
    public Class[] contracts() default {};
    public String[] properties() default {};
    public boolean useQualifiersAsProperties() default false;
}</programlisting>
                <para>This annotation notice that this type is an OSGi service that may be
                    automatically published in the OSGi service registry.</para>
            </section>
            <section>
                <title>The <code>Required</code> annotation</title>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface Required {
}</programlisting>
                <para>This annotation qualifies an injection point that represents a required
                    service.</para>
            </section>
            <section>
                <title>The <code>Filter</code> annotation</title>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface Filter {
    String value();
}</programlisting>
                <para>This annotation qualifies an injection point with an LDAP filter.</para>
            </section>
            <section>
                <title>The <code>Specification</code> annotation</title>
                <programlisting>@Qualifier
@Target({ PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Specification {
    Class value();
}</programlisting>
                <para>This annotation qualifies an injection point by specifying the expected
                    specification class.</para>
            </section>
            <section>
                <title>The <code>Sent</code> annotation</title>
                <programlisting>@Qualifier
@Target({ PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Sent {
}</programlisting>
                <para>This annotation qualifies an injection point that represents a incoming inter
                    bundle communication.</para>
            </section>
        </section>
    </section>
    <section>
        <title>A standard bootstrap for CDI container integration: the integration API</title>
        <section>
            <title>Why an integration API</title>
            <para>CDI-OSGi could have been carried out with an internal CDI compliant container and
                work very well. Every one of the specifications above would have been fulfilled. But
                no other specific utilities or CDI evolution could have been added without a
                complete modification of CDI-OSGi.</para>
            <para>Then there is the integration API. With that, developers are able to provide their
                own implementation bundle. Thus it is possible to use any CDI compliant container
                with a CDI-OSGi application or mix up different CDI compliant containers for
                different bundles.</para>
            <para>Integration API describe what needs the extension bundle to work (and therefore
                what may provide the implementation bundle) and what provides the extension bundle
                (and therefore what should use the implementation bundle).</para>
            <section>
                <title>The <code>BundleContainer</code> and <code>BundleContainers</code>
                    interfaces</title>
                <programlisting>public interface BundleContainer {
    void fire(InterBundleEvent event);
}</programlisting>
                <programlisting>public interface BundleContainers {
    Collection&lt;BundleContainer> getContainers();
}</programlisting>
                <para>These interfaces represent the CDI compliant containers used by bean bundle.
                    Such container may be accessible in the OSGi application to provide an event
                    notification system.</para>
                <para>Multiple containers can be manipulated by the <code>BundleContainers</code>
                    interface.</para>
            </section>
            <section>
                <title>The <code>BundleContainerFactory</code> interface</title>
                <programlisting>public interface BundleContainerFactory {

    Class&lt;? extends BundleContainerFactory> delegateClass();
    String getID();
    Set&lt;String> getContractBlacklist()
    BundleContainer container(Bundle bundle);
}</programlisting>
                <para>This the how the extension bundle require a CDI compliant container from the
                    implementation bundle. This latter should publish an OSGi service that complies
                    with this interface.</para>
            </section>
        </section>
        <section>
            <title>Embedded mode</title>
            <para>TODO How does it work ? Should we provide something ? Should business bundles use
                the integration API ? A template activator ?</para>
        </section>
    </section>
    <section>
        <title>An orchestrator : the extension bundle</title>
        <para> </para>
        <section>
            <title>The extension bundle works that way:</title>
            <para>
                <programlisting>BEGIN
    start
    WHILE ! implementation_bundle.isStarted
        wait
    END_WHILE
    obtain_container_factory
    FOR bean_bundle : started_bundles
        manage_bean_bundle
        provide_container
    END_FOR
    WHILE implementation_bundle.isStarted
        wait_event
        OnBeanBundleStart
            manage_bean_bundle
            provide_container
        OnBeanBundleStop
            unmanage_bean_bundle
    END_WHILE
    stop
    FOR bean_bundle : namaged_bundles
        unmanage_bean_bundle
        stop_bean_bundle
    END_FOR
END</programlisting>
            </para>
        </section>
    </section>
    <section>
        <title>A interchangeable CDI container factory: the implementation bundle</title>
        <para>The implementation bundle is is necessary in a CDI-OSGi application. This section
            explains the part the implementation bundle plays but does not enter in specifics
            because it depends on the CDI vendor implementation used.</para>
        <para>Weld-OSGi chapter presents how an implementation bundle can work.</para>
        <section>
            <title>A implementation bundle may work that way:</title>
            <para>
                <programlisting>BEGIN
    start
    register_container_factory_service
    WHILE true
        wait
        OnContainerRequest
            provide_container
    END_WHILE
    unregister_container_factory_service
END</programlisting>
            </para>
        </section>
    </section>
    <section>
        <title>How to make a bundle or a bean archive a bean bundle</title>
        <para>There are very few things to do in order to obtain a bean bundle from a bean archive
            or a bundle. Mostly it is just adding the missing marker files and headers in the
            archive: <itemizedlist>
                <listitem>
                    <para> Make a bean archive a bean bundle by adding special OSGi marker headers
                        in its <code>META-INF/Manifest.MF</code> file.</para>
                </listitem>
                <listitem>
                    <para> Or, in the other way, make a bundle a bean bundle by adding a
                            <code>META-INF/bean.xml</code> file.</para>
                </listitem>
            </itemizedlist></para>
        <para>Thus a bean bundle has both <code>META-INF/bean.xml</code> file and OSGi marker
            headers in its <code>META-INF/Manifest.MF</code> file.</para>
        <para>However there is a few other information that CDI-OSGi might need in order to perform
            a correct extension. In particular a bean bundle can not be manage by the extension
            bundle but by his own embedded CDI container. For that there is a new manifest
            header.</para>
        <section>
            <title>The <code>META-INF/bean.xml</code> file </title>
            <para>The beans.xml file follows no particular rules and should be the same as in a
                native CDI environment. Thus it can be completely empty or declare interceptors,
                decorators or alternatives as a regular CDI beans.xml file.</para>
            <para>There will be no different behavior with a classic bean archive except for CDI
                OSGi extension new utilities. But these don't need any modification on the
                    <code>META-INF/bean.xml</code> file.</para>
        </section>
        <section>
            <title>The Embedded-CDIContainer <code>META-INF/Manifest.MF</code> header </title>
            <para>This header prevents the extension bundle to automatically manage the bean bundle
                that set this manifest header to true. So the bean bundle can be manage more finely
                by the user or use a different CDI container. If this header is set to false or is
                not present in the <code>META-INF/Manifest.MF</code> file then the bean bundle will
                be automatically manage by the extension bundle (if it is started).</para>
        </section>
    </section>
</chapter>