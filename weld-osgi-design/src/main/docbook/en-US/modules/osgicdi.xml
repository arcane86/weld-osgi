<chapter>
    <title id="osgicdipresentation">Organization of OSGi-CDI</title>
    <section>
        <title>APIs and extension bundle</title>
        <para>
            OSGi-CDI is composed of two bundles. One provides the APIs used to define utilities provided and hooking
            up
            system with CDI container, the other the implementation et CDI management over OSGi environment.
        </para>
        <para>
            The APIs bundle exposed all packages that could be needed by developers; both for client application
            using
            OSGi-CDI and for CDI compliant container integration. These two sides are presented in the next sections.
        </para>
        <para>
            The extension bundle is the orchestrator of OSGi-CDI. It may be use by any application that require
            OSGi-CDI. It runs in shadow using a CDI compliant container. This bundle is presented at the end of this
            section.
        </para>
        <section>
            <title>Extention API versus integration API</title>
            <para>
                OSGi-CDI APIs bundle provides two distinct APIs:
                <itemizedlist>
                    <listitem>
                        <para>
                            The extension API that describes all the new functionality provided by OSGi-CDI in the
                            OSGi
                            environment.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The integration API that allows CDI compliant container to be used with OSGi-CDI.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                These two APIs are more described below.
            </para>
            <section>
                <title>Extension API</title>
                <para>
                    The extension API defines all the utilities provided to OSGi environment using CDI specification.
                    It exposes all the new utilities and defines the comportment of the extension bundle.
                </para>
                <para>
                    It exposes all the interfaces, events and annotations usable by a developers in order to realize
                    its
                    client bean bundle. It defines the programming model of OSGi-CDI client bundle. Mostly it is
                    about
                    publishing and consuming injectable services in a CDI way to do.
                </para>
                <para>
                    It also describes the object the extension bundle needs to orchestrate bean bundles.
                </para>
                <para>
                    So this where to search for the new usages you could do of OSGi.
                </para>
            </section>
            <section>
                <title>Integration API</title>
                <para>
                    The integration API defines how a CDI container, such as Weld, should bootstrap with the CDI OSGi
                    extension. So any CDI environment implementation could use the CDI OSGi extension transparently. The CDI compliant container may be provided using a implementation bundle.
                </para>
                <para>
                    This aims at providing the minimum integration in order to start a CDI compliant container with
                    every
                    managed bean bundle. Then the extension bundle can get a CDI container to provide to every
                    one
                    of
                    its manages bean bundle.
                </para>
                <para>
                    Moreover the integration API allows to mix CDI compliant container in the same application by
                    providing
                    a embedded mode. In this mode a bean bundle is decoupled from the extension bundle and is
                    managed
                    on its own. Thus you can use various implementations of CDI container or particularize the
                    behavior

                    of a
                    particular bean bundle.
                </para>
                <para>
                    All this bootstrapping mechanism works using the service layer of OSGi. A CDI compliant implementation
                    bundle may provide a service that allows the extension bundle to obtain a new container for
                    every bean bundle.
                </para>
                <para>
                    So this where to search to make OSGi-CDI use your CDI compliant container.
                </para>
            </section>
        </section>
        <section>
            <title>Extension bundle : the puppet master</title>
            <para>
                The extension bundle is the heart of OSGi-CDI application. Once it is started, providing that it
                finds a CDI compliant container to use, it manages all the bean bundle. It is in charge of
                inter-bundle
                injection, service injection, OSGi to CDI and inter-bundle communications.
            </para>
            <para>
                It is a worker in the shadow, it just need to be started at the beginning of the application, then
                everything is transparent the user. Client bundles do not have to do anything in order to use
                OSGi-CDI
                functionality. They just use CDI injection and service injection.
            </para>
            <para>
                In order to perform injections the extension bundle search for a CDI compliant container service
                provider
                once it is started. Thus it can only work coupled with a bundle providing such a service.
            </para>
            <para>
                So this is where the magic happens and where your OSGi application become much more simple.
            </para>
        </section>
        <para>
            The next sections explain in details the capacity of these three artifacts.
        </para>
    </section>
    <section>
        <title>An OSGi extension for CDI support</title>
        <section>
            <title>The extender pattern</title>
            <para>
                OSGi-CDI provides an extension to OSGi as an extender OSGi pattern. The extension bundle, the
                extender, tracks for bean bundles, the extensions, to be started. Then CDI utilities are enabled for
                these bean bundles over OSGi environment.
            </para>
        </section>
        <section>
            <title>OSGi-CDI features</title>
            <para>
                As an extension to OSGi, OSGi-CDI provides several features :
                <itemizedlist>
                    <listitem>
                        <para>
                            Complete integration in OSGi world by the use of extender pattern and extension bundle.
                            Thus
                            complete compatibility with already existent tools.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Non intruding, configurable and customizable behavior in new or upgraded application.
                            Simple
                            configuration and usage using annotation, completely xml free.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Intern full CDI support for application bundles: injection, producers, interceptors,
                            decorators ...
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Lot of ease features for OSGi usages: injectable services, event notifications,
                            inter-bundle
                            communication ...
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            OSGi and CDI compliance all along the way ensuring compatibility with all CDI compliant
                            container and easy application realisation or portage.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                We will see in the next sections these features in deep.
            </para>
        </section>
        <section>
            <title>The interfaces</title>
            <para>
                The extension API provides few interfaces that describe all specifics about OSGi service injection.
            </para>
        <section>
            <title>The <code>Service</code> interface</title>
            <programlisting>
                public interface Service&lt;T&gt; extends Instance&lt;T&gt; {
                }
            </programlisting>
            <para>
                It represent a service producer parametrized by the service you want to inject. It has the same
                comportment than
                <code>Instance&lt;T&gt;</code>
                except that it represents only OSGi service beans.
            </para>
        </section>
        <section>
            <title>The <code>Registration</code> and <code>Registrations</code> interfaces</title>
            <programlisting>
                public interface Registration&lt;T&gt; {
                    void unregister();
                    &lt;T&gt; Service&lt;T&gt; getServiceReference();
                }
            </programlisting>
            <programlisting>
                public interface Registrations&lt;T&gt; extends Iterable&lt;Registration&lt;T&gt;&gt; {
                    int size();
                }
            </programlisting>
            <para>
                These interfaces represent the registrations of a injectable OSGi services in the service resgistry.
                It
                permits to act on a previously registered service.
                <code>Unregister()</code>
                remove the service from the service registry and
                <code>&lt;T&gt; Service&lt;T&gt; getServiceReference()</code>
                return the
                <code>Service&lt;T&gt;</code>
                object representing the registred service.
            </para>
            <para>
                Multiple registrations can be manipulated by the iterable <code>Registrations</code> interface.
            </para>
        </section>
        <section>
            <title>The <code>ServiceRegistry</code> interface</title>
            <programlisting>
                public interface ServiceRegistry {
                    &lt;T&gt; Registration&lt;T&gt; registerService(Class&lt;T&gt; contract, Class&lt;? extends T&gt; implementation);
                    &lt;T, U extends T&gt; Registration&lt;T&gt; registerService(Class&lt;T&gt; contract, U implementation);
                    &lt;T&gt; Service&lt;T&gt; getServiceReferences(Class&lt;T&gt; contract);
                    &lt;T&gt; Service&lt;T&gt; getServiceReference(Class&lt;T&gt; contract);
                    &lt;T&gt; Provider&lt;T&gt; newTypeInstance(Class&lt;T&gt; unmanagedType);
                }
            </programlisting>
            <para>
                This is where the injectable services may be registered and retrieved. It allows to register services
                with their interface and implementation, getting back the corespondent
                <code>Registration&lt;T&gt;</code>
                , to obtain the
                <code>Service&lt;T&gt;</code>
                object corresponding to an service interface or to product a new instance of an unmanaged type.
            </para>
        </section>
        </section>
        <section>
            <title>The events</title>
            <para>
                Extension API exposes various events that notify about new life-cycle steps for container management,
                service injection management and communication between bean bundles. They all use CDI event.
            </para>
        <section>
            <title>The <code>BundleContainerInitialized</code> and <code>BundleContainerShutDown</code> events</title>
            <programlisting>
                public class BundleContainerInitialized {
                    private BundleContext bundleContext;

                    public BundleContainerInitialized(final BundleContext context) {
                        this.bundleContext = context;
                    }

                    public BundleContext getBundleContext() {
                        return bundleContext;
                    }
                }
            </programlisting>
            <programlisting>
                public class BundleContainerShutdown {

                    private BundleContext bundleContext;

                    public BundleContainerShutdown(final BundleContext context) {
                        this.bundleContext = context;
                    }

                    public BundleContext getBundleContext() {
                        return bundleContext;
                    }
                }
            </programlisting>
            <para>
                These two events advise bean bundle about the state of its CDI compliant container. They are fired
                respectively when the container has finished its initialization and when the container begin to
                shutdown. They may be fired by the CDI compliant container run with OSGi-CDI. They expose the
                coresponding <code>BundleContext</code>.
            </para>
        </section>
        <section>
            <title>The <code>BundleEvents</code> events</title>
            <para>
                It regroups all the events about bundle life-cycle.
            </para>
            <programlisting>
                public class BundleEvents {

                    public static class BundleInstalled extends AbstractBundleEvent {
                        ...
                    }

                    public static class BundleLazyActivation extends AbstractBundleEvent {
                        ...
                    }

                    public static class BundleResolved extends AbstractBundleEvent {
                        ...
                    }

                    public static class BundleStarted extends AbstractBundleEvent {
                        ...
                    }

                    public static class BundleStarting extends AbstractBundleEvent {
                        ...
                    }

                    public static class BundleStopped extends AbstractBundleEvent {
                        ...
                    }

                    public static class BundleStopping extends AbstractBundleEvent {
                        ...
                    }

                    public static class BundleUninstalled extends AbstractBundleEvent {
                        ...
                    }

                    public static class BundleUnresolved extends AbstractBundleEvent {
                        ...
                    }

                    public static class BundleUpdated extends AbstractBundleEvent {
                        ...
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleInstalled extends AbstractBundleEvent {
                    public BundleInstalled(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.INSTALLED;
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleLazyActivation extends AbstractBundleEvent {
                    public BundleLazyActivation(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.LAZY_ACTIVATION;
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleResolved extends AbstractBundleEvent {
                    public BundleResolved(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.RESOLVED;
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleStarted extends AbstractBundleEvent {
                    public BundleStarted(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.STARTED;
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleStarting extends AbstractBundleEvent {
                    public BundleStarting(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.STARTING;
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleStopped extends AbstractBundleEvent {
                    public BundleStopped(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.STOPPED;
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleStopping extends AbstractBundleEvent {
                    public BundleStopping(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.STOPPING;
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleUninstalled extends AbstractBundleEvent {
                    public BundleUninstalled(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.UNINSTALLED;
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleUnresolved extends AbstractBundleEvent {
                    public BundleUnresolved(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.UNRESOLVED;
                    }
                }
            </programlisting>
            <programlisting>
                public static class BundleUpdated extends AbstractBundleEvent {
                    public BundleUpdated(Bundle bundle) {
                        super(bundle);
                    }

                    @Override
                    public EventType getType() {
                        return EventType.UPDATED;
                    }
                }
            </programlisting>
            <para>
                These events are automatically fired by OSGi-CDI and transmitted to other bundles when the
                corresponding
                life-cycle step occurs in a bean bundle.
            </para>
        </section>
        <section>
            <title>The <code>ServiceArrival</code>, <code>ServiceChanged</code> and <code>ServiceDeparture</code> events</title>
            <programlisting>
                public class ServiceArrival extends AbstractServiceEvent {
                    public ServiceArrival(ServiceReference ref, BundleContext context) {
                        super(ref, context);
                    }

                    @Override
                    public EventType eventType() {
                        return EventType.SERVICE_ARRIVAL;
                    }
                }
            </programlisting>
            <programlisting>
                public class ServiceChanged extends AbstractServiceEvent {
                    public ServiceChanged(ServiceReference ref, BundleContext context) {
                        super(ref, context);
                    }

                    @Override
                    public EventType eventType() {
                        return EventType.SERVICE_CHANGED;
                    }
                }
            </programlisting>
            <programlisting>
                public class ServiceDeparture extends AbstractServiceEvent {
                    public ServiceDeparture(ServiceReference ref, BundleContext context) {
                        super(ref, context);
                    }

                    @Override
                    public EventType eventType() {
                        return EventType.SERVICE_DEPARTURE;
                    }
                }
            </programlisting>
            <para>
                These events are automatically fired by OSGi-CDI and transmitted to other bundles when the
                corresponding
                life-cycle step occurs in a OSGi service.
            </para>
        </section>
        <section>
            <title>The <code>AbstractBundleEvent</code> and <code>AbstractServiceEvent</code> events</title>
            <para>

            </para>
        </section>
        <section>
            <title>The <code>Valid</code> and <code>Invalid</code> events</title>
            <para>

            </para>
        </section>
        </section>
        <section>
            <title>The annotations</title>
            <para>

            </para>
            <section>
                <title>TO BE CONTINUED</title>
            </section>
        </section>
    </section>
    <section>
        <title>A standard bootstrap API for CDI container integration</title>
        <section>
            <title>Intergration API</title>
            <para>
                TODO
            </para>
            <section>
                <title>The
                    <code>BundleContainer</code>
                    and
                    <code>BundleContainers</code>
                    interfaces
                </title>
                <programlisting>
                    public interface BundleContainer {
                    void fire(InterBundleEvent event);
                    }
                </programlisting>
                <programlisting>
                    public interface BundleContainers {
                    Collection&lt;BundleContainer&gt; getContainers();
                    }
                </programlisting>
                <para>
                    These interfaces represent the CDI compliant containers used by bean bundle. Such container may be
                    accessible in the OSGi application to provide an event notification system.
                    <code>void fire(InterBundleEvent event)</code>
                    fire an event through the CDI compliant container.
                </para>
                <para>
                    Multiple containers can be manipulated by the
                    <code>BundleContainers</code>
                    interface.
                </para>
            </section>
        </section>
        <section>
            <title>Embedded mode</title>
            <para>
                TODO
            </para>
        </section>
    </section>
    <section>
        <title>A orchestrator : the extension bundle</title>
        <para>

        </para>
        <section>
            <title>The extension bundle works that way:</title>
            <para>
                <programlisting>
                    BEGIN
                    start
                    WHILE ! implementation_bundle.isStarted
                    wait
                    END_WHILE
                    obtain_container
                    FOR bean_bundle : started_bundles
                    manage_bean_bundle
                    provide_container
                    END_FOR
                    WHILE implementation_bundle.isStarted
                    wait_event
                    OnBeanBundleStart
                    manage_bean_bundle
                    provide_container
                    OnBeanBundleStop
                    unmanage_bean_bundle
                    END_WHILE
                    stop
                    FOR bean_bundle : namaged_bundles
                    unmanage_bean_bundle
                    stop_bean_bundle
                    END_FOR
                    END
                </programlisting>
            </para>
        </section>
        <section>
            <title>A implementation bundle may work that way:</title>
            <para>
                <programlisting>
                    HOW DO I WORK ?
                </programlisting>
            </para>
        </section>
    </section>

    <section>
        <title>How to make a bundle or a bean archive a bean bundle</title>
        <para>
            There are very few things to do in order to obtain a bean bundle from a bean archive or a bundle. Mostly
            you should just add the missing marker file in the archive:
        </para>
        <para>
            <itemizedlist>
                <listitem>
                    <para>
                        Take your bean archive and make it a bean bundle by adding a
                        <code>META-INF/Manifest.MF</code>
                        file.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Or, in the other way, take your bundle and make it a bean bundle by adding a
                        <code>META-INF/bean.xml</code>
                        file.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            However there is a few other information that Weld-OSGi might need in order to perform a correct
            extension.
            In particular you might want a bean bundle to be not manage by the extension bundle but by his own
            embedded CDI container. For that there is a new manifest header.
        </para>
        <section>
            <title>The
                <code>META-INF/bean.xml</code>
                file
            </title>
            <para>
                The beans.xml file follows no particular rules and should be the same as in a native CDI environment.
                Thus it can be completely empty or declare interceptors, decorators or alternatives as a regular CDI
                beans.xml file.
            </para>
            <para>
                There will be no different behavior with a classic bean archive except for CDI OSGi extension new
                utilities. But these don't need any modification on the
                <code>META-INF/bean.xml</code>
                file.
            </para>
        </section>
        <section>
            <title>The Embedded-CDIContainer
                <code>META-INF/Manifest.MF</code>
                header
            </title>
            <para>
                This header prevents the extension bundle to automatically manage the bean bundle that set this
                manifest header to true. So the bean bundle can be manage more finely by the user or use a different
                CDI
                container. If this header is set to false or is not present in the
                <code>META-INF/Manifest.MF</code>
                file then the bean bundle will be automatically manage by the extension bundle (if it is started).
            </para>
        </section>
    </section>
</chapter>