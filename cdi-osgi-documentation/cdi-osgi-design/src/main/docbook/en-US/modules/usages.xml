<chapter>
    <title id="usages">How to make OSGi easy peasy</title>
    <section>
        <title>Injecting easiness in OSGi world</title>
        <para>CDI-OSGi provides more functionality using CDI in a OSGi environment.</para>
        <para>It mainly focuses on the OSGi service layer. It addresses the difficulties in
            publishing and consuming services. CDI-OSGi allows developers to: <itemizedlist>
                <listitem>
                    <para>Automatically publish CDI beans as OSGi services</para>
                </listitem>
                <listitem>
                    <para>Consume OSGi services as CDI beans</para>
                </listitem>
            </itemizedlist></para>
        <para>CDI-OSGi also provides utilities for event notification and communication in and
            between bundles as well as some general OSGi utilities. CDI-OSGi brings a complete
            support of CDI into bean bundles too.</para>
    </section>
    <section>
        <title>CDI usage in bean bundles</title>
        <para>Everything possible in CDI application is possible in bean bundle. They can take
            advantage of injection, producers, interceptors, decorators and alternative. But
            influence boundary of the CDI compliant container stay within the bean bundle for
            classic CDI usages. So external dependencies cannot be injected and interceptor,
            decorator or alternative of another bean bundle cannot be used (yet interceptors,
            decorators and alternatives still need to be declares in the bean bundle bean.xml file). </para>
        <para>That is all we will say about classic CDI usages, please report to CDI documentation
            for more information.</para>
    </section>
    <section>
        <title>Service bean and auto-published OSGi service</title>
        <para>A CDI-OSGi auto-published service is described by these attributes (and their
            equivalents for a regular OSGi service): <itemizedlist>
                <listitem>
                    <para>A (nonempty) set of service contracts (service class names)</para>
                </listitem>
                <listitem>
                    <para>A set of qualifiers (service properties)</para>
                </listitem>
                <listitem>
                    <para>A scope</para>
                </listitem>
                <listitem>
                    <para>A <code>Publish</code> annotated CDI bean instance (service
                        instance)</para>
                </listitem>
            </itemizedlist></para>
        <para>A CDI-OSGi service bean  is described by these attributes (and their equivalents for
            OSGi service lookup): <itemizedlist>
                <listitem>
                    <para>An <code>OSGiService</code> annotated or <code>Service&lt;T></code> typed
                        injection point</para>
                </listitem>
                <listitem>
                    <para>A type (lookup type)</para>
                </listitem>
                <listitem>
                    <para>A <code>Filter</code> qualifier (lookup LDAP filter)</para>
                </listitem>
                <listitem>
                    <para>A (possibly empty) set of reachable instance (lookup result)</para>
                </listitem>
            </itemizedlist></para>
    </section>
    <section>
        <title>OSGi service auto-publication with <code>Publish</code> annotation </title>
        <para>Annotate a CDI bean class with a <code>Publish</code> annotation makes CDI-OSGi
            register this bean as a OSGi service. Then the service is accessible through CDI-OSGi
            service injection and OSGi classic mechanisms.</para>
        <para>Automatically publish a new service implementation:
            <programlisting>@Publish
public class MyServiceImpl implements MyService {
}</programlisting></para>
        <para>However, such an implementation also provides a regular CDI managed bean, so
            MyServiceImpl can also be injected using CDI within the bean bundle.</para>
        <section>
            <title>Service type resolution</title>
            <para>CDI-OSGi auto-published service get their types from the following algorithm:<itemizedlist>
                    <listitem>
                        <para>If a (nonempty) contract list is provided (as an array of
                                <code>Class</code>) with the <code>Publish</code> annotation the
                            service is registered for all these types. This is how define a contract
                            list:<programlisting>@Publish(contracts = {
        MyService.class,
        AbstractClass.class
})
public class MyServiceImpl extends AbstractClass implements MyService, OtherInterface {
}</programlisting>The
                            implementation class may be assignable for all of the contract types. If
                            not, CDI-OSGi detects the problem and treats it as an error.</para>
                    </listitem>
                    <listitem>
                        <para>Else if the implementation class possesses a (nonempty) list of
                            non-blacklisted interfaces the service is registered for all these
                            interface types.The blacklist is described below.</para>
                    </listitem>
                    <listitem>
                        <para>Else if CDI-OSGi the implementation class possesses a non-blacklisted
                            superclass the service is registered for this superclass type.</para>
                    </listitem>
                    <listitem>
                        <para>Last if the implementation class has neither contract nor
                            non-blacklisted interface or superclass, the service is register with is
                            the implementation class type.</para>
                    </listitem>
                </itemizedlist></para>
        </section>
        <section>
            <title>Service type blacklist</title>
            <para>An CDI implementation bundle might provide a type blacklist in order to filter
                auto-published OSGi service allowed type. Please refer to the CDI implementation
                bundle documentation to see if such a blacklist is enable and how to configure
                it.</para>
        </section>
    </section>
    <section>
        <title><code>OSGiService</code> annotated or <code>Service&lt;T></code> typed injection
            points</title>
        <para>A <code>OSGiService</code> annotated or a <code>Service&lt;T></code> typed injection
            point is managed by CDI-OSGi through the creation of a new service
                bean.<code>OSGiService</code> annotation and <code>Service&lt;T></code> type are
            exclusive on injection point. If an injection point has both, CDI-OSGi detects the
            problem and treats it as an error.</para>
        <itemizedlist>
            <listitem>
                <para>Direct injection with <code>OSGiService</code> annotation and
                        <code>OSGiServiceBean</code>:
                    <programlisting>@Inject @OSGiService MyService service;</programlisting>Such an
                    injection point (an OSGi service injection point) will match an unique CDI-OSGi
                        <code>OSGiServiceBean</code>.</para>
                <para>For every different OSGi service injection point an unique
                        <code>OSGiServiceBean</code> is generated by CDI-OSGi.</para>
            </listitem>
            <listitem>
                <para>Injection using programmatic lookup with <code>Service&lt;T></code> type and
                        <code>OSGiServiceProviderBean</code>:
                    <programlisting>@Inject Service&lt;MyService> services;</programlisting>Such an
                    injection point (an OSGi service provider injection point) will match an unique
                    CDI-OSGi <code>OSGiServiceProviderBean</code>.</para>
                <para>For every different OSGi service provider injection point an unique
                        <code>OSGiServiceProviderBean</code> is generated by CDI-OSGi.</para>
            </listitem>
        </itemizedlist>
        <para>
            <code>OSGiService</code> annotated or a <code>Service&lt;T></code> typed injection
            points are not eligible to regular CDI injection.</para>
    </section>
    <section>
        <title><code>OSGiServiceBean</code> and <code>OSGiServiceProviderBean</code></title>
        <para><code>OSGiServiceBean</code> injects an instance of the first service implementation
            matching the injection point.</para>
        <para><code>OSGiServiceProviderBean</code> injects a service provider (as a
                <code>Service&lt;T></code>) for all the service implementations matching the
            injection point.</para>
        <para>Service provider allows to over-specify the matching service implementation set with
            additional OSGi service properties.</para>
        <para>Service provider does not allow to subtype the matching service implementation
            set.</para>
        <para>Service provider allows to instantiate the first service implementation matching the
            (possibly) over-specified injection point.</para>
    </section>
    <section>
        <title>Clearly specify a service implementation</title>
        <para><code>Qualifier</code> annotated annotations might be use for both specifying
            auto-published services and service injection points. Such qualifiers should be seen as
            OSGi service properties, thus every set of qualifiers corresponds to a set of OSGi
            service properties and so to a OSGi service LDAP filter.</para>
        <para>However qualifiers keep a regular meaning for the CDI generated bean of an
            auto-published service class.</para>
        <section>
            <title>Link between qualifiers and OSGi LDAP properties</title>
            <para>A qualifier will generate an OSGi service property for each of its valued element
                (an element with a default value is always considered valued) following these rules:<itemizedlist>
                    <listitem>
                        <para>A valued element generate a property with this
                            template:<programlisting><emphasis role="italic">decapitalized_qualifier_name</emphasis>.<emphasis role="italic">decapitalized_element_name</emphasis>=<emphasis role="italic">element_value.toString()</emphasis></programlisting><programlisting>@MyQualifier(lang="EN", country="US")</programlisting>will
                            generate:<programlisting>(myqualifier.lang=EN)
(myqualifier.country=US)</programlisting></para>
                    </listitem>
                    <listitem>
                        <para>A non valued element with a default value generate a property with
                            this
                            template:<programlisting><emphasis role="italic">decapitalized_qualifier_name</emphasis>.<emphasis role="italic">decapitalized_element_name</emphasis>=<emphasis role="italic">element_default_value.toString()</emphasis></programlisting><programlisting>@MyQualifier(lang="EN")</programlisting>will
                            generate:<programlisting>(myqualifier.lang=EN)
(myqualifier.country=US) //admitting US is the default value for the element country</programlisting></para>
                    </listitem>
                    <listitem>
                        <para>A non valued element with no default value generate a property with
                            this
                            template:<programlisting><emphasis role="italic">decapitalized_qualifier_name</emphasis>.<emphasis role="italic">decapitalized_element_name</emphasis>=*</programlisting><programlisting>@MyQualifier(lang="EN")</programlisting>will
                            generate:<programlisting>(myqualifier.lang=EN)
(myqualifier.country=*) //admitting there is no default value for the element country</programlisting></para>
                    </listitem>
                    <listitem>
                        <para>A qualifier with no element generate a property with this
                            template:<programlisting><emphasis role="italic">decapitalized_qualifier_name</emphasis>=*</programlisting><programlisting>@MyQualifier()</programlisting>will
                            generate:<programlisting>(myqualifier=*)</programlisting></para>
                    </listitem>
                </itemizedlist></para>
        </section>
        <section>
            <title>Special qualifiers</title>
            <itemizedlist>
                <listitem>
                    <para><code>OSGiService</code> qualifier will not generate any service
                        property.</para>
                </listitem>
                <listitem>
                    <para><code>Filter</code> qualifier undergoes a special processing: <itemizedlist>
                            <listitem>
                                <para>Its value element value is reused as it is as a supposedly
                                    valid OSGi service LDAP filter</para>
                            </listitem>
                            <listitem>
                                <para>Its each of the string of its properties element (an array of
                                    string)  is reused as it is as a supposedly valid OSGi service
                                    property</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
            </itemizedlist>
            <para>It is discourage to use the <code>Filter</code> qualifier on a bean that might be
                use as a regular CDI bean.</para>
        </section>
        <section>
            <title>Final LDAP filter</title>
            <para>CDI-OSGi processes all the OSGi LDAP properties and provided OSGi LDAP filter to
                generate a global OSGi LDAP filter as:<itemizedlist>
                    <listitem>
                        <para>With multiple OSGi LDAP properties and a provided OSGi LDAP
                            filter<programlisting>(&amp; <emphasis role="italic">provided_ldap_filter</emphasis> (<emphasis role="italic">ldap_property_1</emphasis>) (<emphasis role="italic">ldap_property_2</emphasis>) ... (<emphasis role="italic">ldap_property_i</emphasis>) )</programlisting></para>
                    </listitem>
                    <listitem>
                        <para>With multiple OSGi LDAP properties and no provided OSGi LDAP
                            filter<programlisting>(&amp; (<emphasis role="italic">ldap_property_1</emphasis>) (<emphasis role="italic">ldap_property_2</emphasis>) ... (<emphasis role="italic">ldap_property_i</emphasis>) )</programlisting></para>
                    </listitem>
                    <listitem>
                        <para>With one OSGi LDAP properties and a provided OSGi LDAP
                            filter<programlisting>(&amp; <emphasis role="italic">provided_ldap_filter</emphasis> (<emphasis role="italic">ldap_property</emphasis>) )</programlisting></para>
                    </listitem>
                    <listitem>
                        <para>With one OSGi LDAP properties and no provided OSGi LDAP
                            filter<programlisting>(<emphasis role="italic">ldap_property</emphasis>)</programlisting></para>
                    </listitem>
                    <listitem>
                        <para>With no OSGi LDAP properties and a provided OSGi LDAP
                            filter<programlisting><emphasis role="italic">provided_ldap_filter</emphasis></programlisting></para>
                    </listitem>
                    <listitem>
                        <para>With no OSGi LDAP properties and no provided OSGi LDAP
                            filter<programlisting>(*)</programlisting></para>
                    </listitem>
                </itemizedlist></para>
            <para>CDI-OSGi never ensure that, neither the provided OSGi LDAP properties, neither the
                provided OSGi LDAP filter, neither the generated OSGi LDAP filter, are valid.
            </para>
        </section>
        <section>
            <title>Using service filtering</title>
            <itemizedlist>
                <listitem>
                    <para>On an auto-published service class:
                        <programlisting>@Publish
@AnyQualifier
public class MyServiceQualifiedImpl implements MyService {
}</programlisting>Will
                        generate an <code>AnyQualifier</code> qualified regular CDI bean and
                        register an OSGi service with the property (anyqualifier=*).</para>
                </listitem>
                <listitem>
                    <para>On an OSGi service injection point:
                        <programlisting>@Inject @OSGiService @AnyQualifier MyService qualifiedService;
@Inject @AnyQualifier Service&lt;MyService> qualifiedServices;</programlisting>Will
                        generate an <code>OSGiServiceBean</code> and an
                            <code>OSGiServiceProducerBean</code> looking up for OSGi services with
                        the  property (anyqualifier=*).</para>
                </listitem>
                <listitem>
                    <para>With an
                        <code>OSGiServiceProducerBean</code>:<programlisting>services.select(new AnnotationLiteral&lt;AnyQualifier>() {}).get().deSomething();</programlisting>Will
                        over-specify the valid service implementation set to those matching the
                        property (anyqualifier=*).</para>
                </listitem>
                <listitem>
                    <para>Using the special <code>Filter</code>
                        qualifier:<programlisting>@Publish
@Filter(value="(lang=EN)",
        properties = {"country=US",
                      "currency=*")
        })
public class MyServiceQualifiedImpl implements MyService {
}</programlisting>Will
                        generate an <code>Filter(...)</code> qualified regular CDI bean and register
                        an OSGi service with the properties (lang=EN) [as a complete OSGi service
                        LDAP filter], (country=US) and (currency=*). </para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Bean disambiguation and annotated type processing</title>
        <para>CDI-OSGi ensures that every <code>OSGiService</code> annotated or
                <code>Serive&lt;T></code> typed injection point matches an unique
                <code>OSGiServiceBean</code> or <code>OSGiServiceProviderBean</code>.</para>
        <para>Therefore, for every bean bundle CDI-OSGi:<itemizedlist>
                <listitem>
                    <para>Processes annotated types</para>
                </listitem>
                <listitem>
                    <para>Wraps every  <code>OSGiService</code> annotated or
                            <code>Service&lt;T></code> typed injection point</para>
                </listitem>
            </itemizedlist></para>
        <para><code>OSGiService</code> annotated injection points are wrapped
            as:<programlisting>@Inject @OSGiService @Filter(<emphasis role="italic">Calculated_filter</emphasis>) <emphasis role="italic">Type</emphasis> <emphasis role="italic">var_name</emphasis>;</programlisting></para>
        <para><code>Service&lt;T></code> typed injection points are wrapped
            as:<programlisting>@Inject @Filter(<emphasis role="italic">Calculated_filter</emphasis>) Service&lt;<emphasis role="italic">Type</emphasis>> <emphasis role="italic">var_name</emphasis>;</programlisting></para>
        <para>The global OSGi LDAP filter of the final <code>Filter</code> qualifier is calculated
            from (following the rules above):<itemizedlist>
                <listitem>
                    <para>The original set of qualifiers (except <code>OSGiService</code> and
                            <code>Filter</code>)</para>
                </listitem>
                <listitem>
                    <para>The OSGi LDAP filter value of the original <code>Filter</code>
                        qualifier</para>
                </listitem>
                <listitem>
                    <para>The set of properties of the original <code>Filter</code>
                        annotation</para>
                </listitem>
            </itemizedlist></para>
        <section>
            <title>Examples</title>
            <itemizedlist>
                <listitem>
                    <para><programlisting>@Inject @OSGiService MyService qualifiedService;</programlisting>will
                        become:<programlisting>@Inject @OSGiService <emphasis role="bold">@Filter("(*)")</emphasis> MyService qualifiedService;</programlisting></para>
                </listitem>
                <listitem>
                    <para><programlisting>@Inject @OSGiService <emphasis role="bold">@AnyQualifier</emphasis> MyService qualifiedService;</programlisting>will
                        become:<programlisting>@Inject @OSGiService <emphasis role="bold">@Filter("(anyqualifier=*)")</emphasis> MyService qualifiedService;</programlisting></para>
                </listitem>
                <listitem>
                    <para><programlisting>@Inject <emphasis role="bold">@AnyQualifier</emphasis> Service&lt;MyService> qualifiedServices;</programlisting>will
                        become:<programlisting>@Inject <emphasis role="bold">@Filter("(anyqualifier=*)")</emphasis> Service&lt;MyService> qualifiedService;</programlisting></para>
                </listitem>
                <listitem>
                    <para><programlisting>@Inject <emphasis role="bold">@OSGiService</emphasis> @AnyQualifier <emphasis role="bold">Service&lt;</emphasis>MyService<emphasis role="bold">></emphasis> qualifiedServices;</programlisting>will
                        generate an error.</para>
                </listitem>
                <listitem>
                    <para><programlisting>@Inject @OSGiService <emphasis role="bold">@AnyQualifier</emphasis> <emphasis role="bold">@Filter(value="(lang=EN)",properties={"country=US","currency=*"})</emphasis> MyService qualifiedService;</programlisting>will
                        become:<programlisting>@Inject @OSGiService <emphasis role="bold">@Filter("(&amp;(anyqualifier=*)(lang=EN)(country=US)(currency=*))</emphasis> MyService qualifiedService;</programlisting></para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Justification</title>
            <figure>
                <title>Annotated type processing justification</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="../../../../../../../../../../T%C3%A9l%C3%A9chargements/CDI-OSGipublishconsumecycle.png"
                            depth="800"/>
                    </imageobject>
                    <caption>This figure show the need for a annotated type processing in order to
                        remove the ambiguous dependency between regular CDI and CDI-OSGi injection
                        points.</caption>
                </mediaobject>
            </figure>
        </section>
    </section>
    <section>
        <title>Contextual services</title>
        <para>Like for bean instances, service instances are contextual. Every implementation is
            bounded to a particular scope. Provided that an satisfactory implementation is
            available, a service injection will return a contextual instance of the
            implementation.</para>
        <para>All CDI scopes are available for CDI-OSGi services and their use is the same:
            <programlisting>@Publish
@ApplicationScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}</programlisting>A
            instance will be shared by the entire
            application.<programlisting>@Publish
@RequestScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}                </programlisting>A
            new instance is created for every request.</para>
        <para>If no scope is provided <code>@Dependent</code> is assumed, a new instance will be
            create for every injection.</para>
    </section>
    <section>
        <title>The registration</title>
        <para>A registration object represent all the bindings between a service contract class and
            its OSGi <code>ServiceRegistration</code>s. With this object it is possible to navigate
            through multiple implementations of the same service, obtain the corresponding
                <code>Service&lt;T></code> or unregister these implementations.</para>
        <section>
            <title>registration injection</title>
            <para>A registration is obtained like
                that:<programlisting>@Inject Registration&lt;MyService> registrations;</programlisting>The
                injection point can be filtered using
                qualifiers:<programlisting>@Inject @AnyQualifier Registration&lt;MyService> qualifiedRegistrations;</programlisting>or
                using LDAP
                filter:<programlisting>@Inject @Filter("(&amp;(lang=EN)(country=US))") Registration&lt;MyService> qualifiedRegistrations;</programlisting></para>
        </section>
        <section>
            <title>Navigate into registrations and filter them</title>
            <para>It is possible to iterate through
                registration:<programlisting>if(registrations.size() > 0) {
    for(Registration&lt;T> registration : registrations) {
    }
}</programlisting></para>
            <para>It is also possible to request a subset of the service implementations using
                qualifiers:<programlisting>Registration&lt;T> filteredRegistrations = registrations.select(new AnnotationLiteral&lt;AnyQualifier>() {});</programlisting>or
                a LDAP
                filter:<programlisting>Registration&lt;T> filteredRegistrations = registrations.select("(&amp;(lang=EN)(country=US))");</programlisting>or
                both:<programlisting>Registration&lt;T> filteredRegistrations = registrations.select(new AnnotationLiteral&lt;AnyQualifier>() {}).select("(&amp;(lang=EN)(country=US))");</programlisting>Link
                between qualifier and LDAP filter as well as subtyped service selection are explain
                above in service injection section.</para>
        </section>
        <section>
            <title>Registration usages</title>
            <para>A registration allows to obtain service
                implementations:<programlisting>Service&lt;T> myServiceImplementations = registrations.getServiceReference();</programlisting>And
                it allows to unregister service
                implementations:<programlisting>registrations.unregister();</programlisting></para>
        </section>
    </section>
    <section>
        <title>Service registry</title>
        <para>CDI-OSGi offers another way to deal with services: the service registry. It can be
            obtained in any bundle as a regular service, using OSGi or CDI-OSGi ways. The service
            registry allows developers to dynamically register service implementation, to obtain
            services and registrations.</para>
        <section>
            <title>First get the service registry</title>
            <para>TODO Is the service registry a bean or a service ? If it is a service it could use
                by regular bundle, couldn't it ?</para>
            <para>First get the service registry:
                <programlisting>@Inject @OSGiService ServiceRegistry registry;</programlisting>Or in
                regular bundle:
                <programlisting>ServiceReference reference = bundleContext.getServiceReference(ServiceRegistry.class.getName());
ServiceRegistry registry = (ServiceRegistry) bundleContext.getService(reference);</programlisting></para>
        </section>
        <section>
            <title>Register a service implementation</title>
            <para>Register a service implementation:
                <programlisting>registry.registerService(MyService.class,MyServiceImpl.class);</programlisting>
                or
                <programlisting>@Inject MyServiceImpl implementation;
registry.registerService(MyService.class,implementation);</programlisting>Here
                the scope of the service is ??? (Dependent ?)</para>
            <para>It is possible to collect the corresponding registration:
                <programlisting>Registration&lt;MyService> registeredService = registry.registerService(MyService.class,MyServiceImpl.class);</programlisting></para>
        </section>
        <section>
            <title>Obtain a service implementations</title>
            <para>Obtain a service implementations:
                <programlisting>Service&lt;MyService> services = registry.getServiceReference(MyService.class);
for (MyService service : services) {
    service.doSomething();
}</programlisting></para>
        </section>
        <section>
            <title>Obtain registrations</title>
            <para>Obtain all registrations of a filtered or not filtered specified service:
                <programlisting>Registration&lt;?> registrations = registry.getRegistrations();
Registration&lt;MyService> myRegistrations = registry.getRegistrations(MyService.class);
Registration&lt;MyService> myFrenchRegistrations = registry.getRegistrations(MyService.class,"(lang=FR)");     </programlisting></para>
        </section>
    </section>
    <section>
        <title>Distinctions between CDI-OSGi service injection and CDI bean injection</title>
        <para>All the way it is said that CDI-OSGi service injection is similar with classic CDI
            bean injection. That is true, but there some important distinctions to make. CDI users
            will quickly find their bearings in CDI-OSGi and that is the point because CDI way is
            much more simple that OSGi mechanisms (so CDI-OSGi is also a good thing for newcomers in
            both CDI and OSGi worlds! ).</para>
        <para>The main difference is about the dynamism of OSGi services. While a bean injection
            point should be satisfy at the start of the CDI container, service injection may be
            satisfy only at runtime.</para>
        <para>So what ? TODO Ambiguous and unsatisfied dependency management and other stuffs that
            vary from classic CDI.</para>
        <section>
            <title>The <code>OSGiServiceUnavailableException</code> exception </title>
            <para>Because OSGi service are dynamic they might be unavailable at the time they should
                be used. On a service call if the targeted service isn't available a specific
                runtime exception is raised:
                <programlisting>public class OSGiServiceUnavailableException extends RuntimeException {}</programlisting></para>
        </section>
        <section>
            <title>And everything else ?</title>
            <para>If it is not indicated otherwise assume that the comportment is the same as CDI or
                OSGi without CDI-OSGi.</para>
        </section>
    </section>
    <section>
        <title>CDI-OSGi events</title>
        <para>CDI-OSGi makes heavy usage of CDI events. These events allow CDI-OSGi to do its work.
            Events are important for the running of CDI-OSGi itself but they can also be use by
            client bean bundles to perform some operations or override some normal CDI-OSGi
            behavior.</para>
        <para>This section shows the numerous events provided by CDI-OSGi and the ways to use
            them.</para>
        <section>
            <title>CDI container lifecycle events</title>
            <para>Two events inform about the state of the CDI container of every bean bundle:
                    <code>BundleContainerInitialized</code> and <code>BundleContainerShutdown</code>
                events.</para>
            <para>The <code>BundleContext</code> from where the event comes is sent with these
                events so developers can retrieve useful information (such as the bundle owning the
                CDI container).</para>
            <section>
                <title>When the container is started: <code>BundleContainerInitialized</code>
                    event</title>
                <para>The <code>BundleContainerInitialized</code> event is fired every time a CDI
                    container is initialized in a bean bundle. It point out that the CDI container
                    is ready to manage the bean bundle with the CDI-OSGi features.</para>
                <para>Here the way to listen this event:
                    <programlisting>public void onStartup(@Observes BundleContainerInitialized event) {
    BundleContext bundleContext = event.getBundleContext();
    Bundle firingBundle = bundleContext.getBundle();
}</programlisting></para>
            </section>
            <section>
                <title>When the container is stopped: <code>BundleContainerShutdown</code>
                    event</title>
                <para>The <code>BundleContainerShutdown</code> event is fired every time a CDI
                    container is stopped in a bean bundle. It point out that the CDI container wil
                    not manage the bean bundle with CDI-OSGi anymore.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void onShutdown(@Observes BundleContainerShutdown event) {
    BundleContext bundleContext = event.getBundleContext();
    Bundle firingBundle = bundleContext.getBundle();
}</programlisting></para>
            </section>
        </section>
        <section>
            <title>Bundle lifecycle events</title>
            <para>Ten events might be fired during a bundle lifecycle. They represent the possible
                states of a bundle and monitor the changes occurred in bundle lifecycles. These
                events carry the <code>Bundle</code> object from where the event comes so developers
                can retrieve useful information (such as the bundle id).</para>
            <section>
                <title>Listen all bundle events: <code>AbstractBundleEvent</code> event</title>
                <para>CDI-OSGi provides a way to listen all bundle events in a single method: the
                        <code>AbstractBundleEvent</code> abstract class. Every bundle lifecycle
                    event is an <code>AbstractBundleEvent</code> and a method allows to retrieve the
                    actual fired bundle event. All bundle states are listed in the
                        <code>BundleEventType</code> enumeration. Then this event can be used as the
                    corresponding bundle event.</para>
                <para>Here the way to listen all bundle events and to retrieve the corresponding
                    bundle
                    state:<programlisting>public void bundleChanged(@Observes AbstractBundleEvent event) {
    BundleEventType event.getType();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is installed: <code>BundleInstalled</code> event</title>
                <para>An event is fired every time a bundle is install in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void bindBundle(@Observes BundleInstalled event) {
    Bundle bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is uninstalled: <code>BundleUninstalled</code> event</title>
                <para>An event is fired every time a bundle is uninstall from the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void unbindBundle(@Observes BundleUninstalled event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is lazy activated: <code>BundleLazyActivation</code>
                    event</title>
                <para>An event is fired every time a bundle is lazy activated in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void lazyInitBundle(@Observes BundleLazyActivation event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is resolved: <code>BundleResolved</code> event</title>
                <para>An event is fired every time a bundle is resolved in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void resolveBundle(@Observes BundleResolved event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is unresolved: <code>BundleUnresolved</code> event</title>
                <para>An event is fired every time a bundle is unresolved in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void unresolveBundle(@Observes BundleUnresolved event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is updated: <code>BundleUpdated</code> event</title>
                <para>An event is fired every time a bundle is updated in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void updateBundle(@Observes BundleUpdated event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is started: <code>BundleStarted</code> event</title>
                <para>An event is fired every time a bundle is started in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void startBundle(@Observes BundleStarted event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is starting: <code>BundleStarting</code> event</title>
                <para>An event is fired every time a bundle is starting in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void startingBundle(@Observes BundleStarting event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is stopped: <code>BundleStopped</code> event</title>
                <para>An event is fired every time a bundle is stopped in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void stopBundle(@Observes BundleStopped event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is stopping: <code>BundleStopping</code> event</title>
                <para>An event is fired every time a bundle is stopping in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void stoppingBundle(@Observes BundleStopping event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>Filtering bundle events: <code>BundleName</code> and
                        <code>BundleVersion</code> annotations</title>
                <para>It is possible to filter the listened events depending on the bundles that are
                    concerned. This filter might cover the name or the version of the
                    bundles.</para>
                <para>Here the way to filter bundle events on the bundle
                    names:<programlisting>public void bindBundle(@Observes @BundleName("com.sample.gui") BundleInstalled event) {
}</programlisting>or
                    on the bundle
                    versions:<programlisting>public void bindBundle(@Observes @BundleVersion("4.2.1") BundleInstalled event) {
}</programlisting>or
                    on both bundle names and
                    versions:<programlisting>public void bindBundle(@Observes @BundleName("com.sample.gui") @BundleVersion("4.2.1") BundleInstalled event) {
}</programlisting></para>
            </section>
        </section>
        <section>
            <title>Service lifecyle events</title>
            <para>Three events might be fired during a service lifecycle. They represent the
                possible states of a service and monitor the changes occurred in service lifecycles.
                These events carry the <code>BundleContext</code> object from where the event comes
                and the <code>ServiceReference</code> object correspondign to the service so
                developers can retrieve useful information (such as the registering bundle) and
                acces useful actions (such as register or unregister services).</para>
            <section>
                <title>Listen all service events: <code>AbstractServiceEvent</code> event</title>
                <para>CDI-OSGi provides a way to listen all service events in a single method: the
                        <code>AbstractServiceEvent</code> abstract class. Every service lifecycle
                    event is an <code>AbstractServiceEvent</code> and a method allows to retrieve
                    the actual fired service event. All service states are listed in the
                        <code>ServiceEventType</code> enumeration. Then this event can be used as
                    the corresponding service event.</para>
                <para>Here the way to listen all service events and to retrieve the corresponding
                    service
                    state:<programlisting>public void serviceEvent(@Observes AbstractServiceEvent event) {
    ServiceEventType event.getType();
}</programlisting></para>
            </section>
            <section>
                <title>When a service is published: <code>ServiceArrival</code> event</title>
                <para>An event is fired every time a service is published in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void bindService(@Observes ServiceArrival event) {
    ServiceReference serviceReference = event.getRef();
    Bundle registeringBundle = event.getRegisteringBundle();
}</programlisting></para>
            </section>
            <section>
                <title>When a service is unpublished: <code>ServiceDeparture</code> event</title>
                <para>An event is fired every time a service is unpublished in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void unbindService(@Observes ServiceDeparture event) {
    ServiceReference serviceReference = event.getRef();
    Bundle registeringBundle = event.getRegisteringBundle();
}</programlisting></para>
            </section>
            <section>
                <title>When a service is changed: <code>ServiceChange</code> event</title>
                <para>An event is fired every time a service is changed in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void changeService(@Observes ServiceChange event) {
    ServiceReference serviceReference = event.getRef();
    Bundle registeringBundle = event.getRegisteringBundle();
}</programlisting></para>
            </section>
            <section>
                <title>Filtering service events: <code>Specification</code> and <code>Filter</code>
                    annotations</title>
                <para>It is possible to filter the listened events depending on the services that
                    are concerned. This filter might cover the service specification class or it
                    might be a LDAP filter.</para>
                <para>Here the way to filter service events on the specification
                    class:<programlisting>public void bindService(@Observes @Specification(MyService.class) ServiceArrival event) {
}</programlisting>or
                    using a LDAP
                    filter:<programlisting>public void bindService(@Observes @Specification(MyService.class) ServiceArrival event) {
}</programlisting>or
                    on both specification class and LDAP
                    filter:<programlisting>public void bindService(@Observes @Specification(MyService.class) @Filter("(&amp;(lang=EN)(country=US))") ServiceArrival event) {
}</programlisting></para>
            </section>
        </section>
        <section>
            <title>Application dependency validation events</title>
            <para>Some bean bundle might declare required dependencies on services (using the
                    <code>Required</code> annotation). CDI-OSGi fired events when these required
                dependencies are all validated or when at least one is invalidated. It allows
                application to be automatically started or stopped.</para>
            <section>
                <title>When all dependencies are validated: <code>Valid</code> event</title>
                <para>An event is fired every time all the required dependencies are
                    validated.</para>
                <para>Here the way to listen this event:
                    <programlisting>public void validate(@Observes Valid event) {
}</programlisting></para>
            </section>
            <section>
                <title>When at least one dependency is invalidated: <code>Invalid</code>
                    event</title>
                <para>An event is fired every time at least one of the required dependencies is
                    invalidated.</para>
                <para>Here the way to listen this event:
                    <programlisting>public void invalidate(@Observes Invalid event) {
}</programlisting></para>
            </section>
        </section>
        <section>
            <title>Intra and inter bundles communication events</title>
            <para>CDI-OSGi provides a way to communicate within and between bean bundles. This
                communication occurs in a totally decoupled manner using CDI events.</para>
            <section>
                <title>Firing a bundle communication event: <code>InterBundleEvent</code>
                    event</title>
                <para>An <code>InterBundleEvent</code> is a message containing a object and
                    transmited using CDI event.</para>
                <para>Here the way to fire such an
                    event:<programlisting>@Inject Event&lt;InterBundleEvent> event;
MyMessage myMessage = new MyMessage();
event.fire(new InterBundleEvent(myMessage));</programlisting></para>
            </section>
            <section>
                <title>When a bundle communication is received: <code>InterBundleEvent</code>
                    event</title>
                <para>When an <code>InterBundleEvent</code> is fired it might be catch either within
                    the bundle or in other bundles or both.</para>
                <para>Here the way to receive a communication event from within the
                    bundle:<programlisting>public void listenAllEvents(@Observes InterBundleEvent event) {
}</programlisting></para>
                <para>Here the way to receive a communication event from another
                    bundles:<programlisting>public void listenAllEventsFromOtherBundles(@Observes @Sent InterBundleEvent event) {
}</programlisting></para>
            </section>
            <section>
                <title>Filtering communication events: <code>Specification</code> annotation</title>
                <para>It is possible to filter the listened events depending on the message type.
                    This filter may specify the type of message that is listened.</para>
                <para>Here the way to filter communication events specifying a message type:
                    <programlisting>public void listenStringEventsFromOtherBundles(@Observes @Sent @Specification(MyMessage.class) InterBundleEventevent) {
}</programlisting>Only
                    the message with type <code>MyMessage</code> will be received.</para>
            </section>
        </section>
    </section>
    <section>
        <title>OSGi utilities</title>
        <para>CDI-OSGi provide some facilities for OSGi usage. It allows to obtain, by injection,
            some of the useful objects of the OSGi environment.</para>
        <section>
            <title>From the current bundle</title>
            <para>Here a way to obtain the current
                bundle:<programlisting>@Inject Bundle bundle;</programlisting></para>
            <para>Here a way to obtain the current bundle
                context:<programlisting>@Inject BundleContext bundleContext;</programlisting></para>
            <para>Here a way to obtain all the current bundle
                headers:<programlisting>@Inject @BundleHeaders Map&lt;String,String>metadata;</programlisting>or
                a particular
                header<programlisting>@Inject @BundleHeader("Bundle-SymbolicName") String symbolicName;</programlisting></para>
            <para>Here a way to obtain a resource file from the current
                bundle:<programlisting>@Injec @BundleDataFile("test.txt") File file;</programlisting></para>
        </section>
        <section>
            <title>From external bundle</title>
            <para>Here a way to obtain a specified bundle from its name and
                version:<programlisting>@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") bundle;</programlisting>or
                just from its
                name:<programlisting>@Inject @BundleName("com.sample.gui") bundle;</programlisting></para>
            <para>Here a way to obtain all the specified bundle
                headers:<programlisting>@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") @BundleHeaders Map&lt;String,String>metadata;</programlisting>or
                a particular
                header:<programlisting>@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") @BundleHeader("Bundle-SymbolicName") String symbolicName;</programlisting></para>
        </section>
    </section>
    <section>
        <title>A standard bootstrap for CDI container integration: the integration API</title>
        <section>
            <title>Why an integration API</title>
            <para>CDI-OSGi could have been carried out with an internal CDI compliant container and
                work very well. Every one of the specifications above would have been fulfilled. But
                no other specific utilities or CDI evolution could have been added without a
                complete modification of CDI-OSGi.</para>
            <para>Then there is the integration API. With that, developers are able to provide their
                own integration bundle. Thus it is possible to use any CDI compliant container with
                a CDI-OSGi application or mix up different CDI compliant containers for different
                bundles.</para>
            <para>Integration API describes what needs the extension bundle to work (and therefore
                what may provide the integraton bundle).</para>
            <section>
                <title>The <code>CDIContainer</code> interface</title>
                <programlisting>public interface CDIContainer {

    boolean initialize();

    boolean shutdown();

    boolean isStarted();

    void fire(InterBundleEvent event);

    Bundle getBundle();

    BeanManager getBeanManager();

    Event getEvent();

    Instance&lt;Object> getInstance();

    Collection&lt;String> getBeanClasses();

    Collection&lt;ServiceRegistration> getRegistrations();

    void setRegistrations(Collection&lt;ServiceRegistration> registrations);

}</programlisting>
                <para/>
            </section>
            <section>
                <title>The <code>BundleContainerFactory</code> interface</title>
                <programlisting>public interface BundleContainerFactory {

    Class&lt;? extends BundleContainerFactory> delegateClass();
    String getID();
    Set&lt;String> getContractBlacklist()
    BundleContainer container(Bundle bundle);
}</programlisting>
                <para>This the how the extension bundle require a CDI compliant container from the
                    implementation bundle. This latter should publish an OSGi service that complies
                    with this interface.</para>
            </section>
        </section>
        <section>
            <title>Embedded mode</title>
            <para>TODO How does it work ? Should we provide something ? Should business bundles use
                the integration API ? A template activator ?</para>
        </section>
        <section>
            <title>Integration bundle discovery and CDI-OSGi start</title>
            <figure>
                <title>CDI-OSGi framework start and stop protocol</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/CDI-OSGistartprotocol.png" format="PNG"
                            align="center" width="800" depth="600"/>
                    </imageobject>
                    <caption>This figure shows the steps of the CDI-OSGi starting and stopping
                        protocol. Between step 8 and step 11 the framework is in stable state and
                        manages bean bundles.</caption>
                </mediaobject>
            </figure>
        </section>
    </section>
    <section>
        <title>An orchestrator : the extension bundle TODO</title>
        <section>
            <title>The extender pattern</title>
            <para>CDI-OSGi provides an extension to OSGi as an extender pattern. The extension
                bundle, the extender, tracks for bean bundles, the extensions, to be started. Then
                CDI utilities are enabled for these bean bundles over OSGi environment.</para>
        </section>
        <section>
            <title>The extension bundle works that way:</title>
            <para>
                <programlisting>BEGIN
    start
    WHILE ! implementation_bundle.isStarted
        wait
    END_WHILE
    obtain_container_factory
    FOR bean_bundle : started_bundles
        manage_bean_bundle
        provide_container
    END_FOR
    WHILE implementation_bundle.isStarted
        wait_event
        OnBeanBundleStart
            manage_bean_bundle
            provide_container
        OnBeanBundleStop
            unmanage_bean_bundle
    END_WHILE
    stop
    FOR bean_bundle : namaged_bundles
        unmanage_bean_bundle
        stop_bean_bundle
    END_FOR
END</programlisting>
            </para>
        </section>
    </section>
    <section>
        <title>A interchangeable CDI container factory: the implementation bundle TODO</title>
        <para>The implementation bundle is is necessary in a CDI-OSGi application. This section
            explains the part the implementation bundle plays but does not enter in specifics
            because it depends on the CDI vendor implementation used.</para>
        <para>Weld-OSGi chapter presents how an implementation bundle can work.</para>
        <section>
            <title>A implementation bundle may work that way:</title>
            <para>
                <programlisting>BEGIN
    start
    register_container_factory_service
    WHILE true
        wait
        OnContainerRequest
            provide_container
    END_WHILE
    unregister_container_factory_service
END</programlisting>
            </para>
        </section>
    </section>
</chapter>
