<chapter>
    <title id="usages">How to make OSGi easy peasy</title>
    <section>
        <title>CDI usage in bean bundles</title>
        <para>Everything possible in CDI application is possible in bean bundle. They can take
            advantage of injection, producers, interceptors, decorators and alternative. But
            influence boundary of the CDI compliant container stay within the bean bundle for
            classic CDI usages. So external dependencies cannot be injected and interceptor,
            decorator or alternative of another bean bundle cannot be used (yet interceptors,
            decorators and alternatives still need to be declares in the bean bundle bean.xml file). </para>
        <para>That is all we will say about classic CDI usages, please report to CDI documentation
            for more information.</para>
    </section>
    <section>
        <title>Injecting easiness in OSGi world</title>
        <para>CDI-OSGi provides more functionality using CDI in a OSGi environment.</para>
        <para>It mainly focuses on the OSGi service layer. It addresses the difficulties in
            publishing and consuming services. CDI-OSGi allows developers to publish and consume
            OSGi services as CDI beans. However, since OSGi services are dynamic there are some
            differences with classic bean injection. This section presents how OSGi services can be
            published and consumed using CDI-OSGi.</para>
        <para>CDI-OSGi also provides utilities for event notification and communication in and
            between bundles as well as some general OSGi utilities.</para>
        <para>Examples use this very sophisticated service interface:
            <programlisting>public interface MyService {
    void doSomething();
}</programlisting></para>
        <section>
            <title>Service, implementation, instance and registration</title>
            <para>First it is important to be clear about what are a service, its implementations,
                its instances and its registrations.</para>
            <para>A service is mostly an interface. This interface defines the contract that
                describes what the service may do. It might be several way to actually providing the
                service, thus a service might have multiple implementations.</para>
            <para>A service implementation is a class that implements this service. It is what is
                available to other components that use the service. To use the service the component
                obtain an instance of the implementation.</para>
            <para>A service instance is an instance of one of the service implementations. It is
                what the user manipulates to perform the service.</para>
            <para>A registration is the object that represents a service registered with a
                particular implementation. Then this implementation can be searched and its
                instances can be obtained. Every time a service implementation his register a
                corresponding registration object is created.</para>
        </section>
        <section>
            <title>OSGi services injection</title>
            <para> There are two ways to obtain a service instances using CDI-OSGi: direct injection
                and programmatic lookup.</para>
            <section>
                <title>Direct injection using <code>@OSGiService</code> annotation </title>
                <para>The main way to perform an OSGi injection is to use the <code>@Inject
                        @OSGiService</code> annotation combination. It acts like a common injection
                    except that CDI-OSGi will search for injectable instances in the OSGi service
                    registry.</para>
                <para>That is how it looks like:
                    <programlisting>@Inject @OSGiService MyService service;
service.doSomething(); </programlisting></para>
                <para>The behavior is similar with classic CDI injection. <code>@OSGiService</code>
                    is just a special qualifier that allows extension bundle to manage the injection
                    instead of implementation bundle. So the injected instance is an OSGi
                    service.</para>
            </section>
            <section>
                <title>Injection using programmatic lookup</title>
                <para>Instead of obtain directly a service instance it is possible to choose between
                    service implementations and instantiate one at runtime. The interface
                        <code>Service&lt;T></code> works as a service instance producer: it
                    retrieves all the corresponding (to the service parametrized type) service
                    implementations and allows to get an instances for each.</para>
                <para>Service implementations and a corresponding instance can be obtained like
                    that:
                    <programlisting>@Inject Service&lt;MyService> services;
services.get().doSomething();</programlisting>All
                    implementations can also be iterated like that:
                    <programlisting>@Inject Service&lt;MyService> services;
for (MyService service : services) {
    service.get().doSomething();
}</programlisting></para>
                <para><code>Service&lt;T></code> extends CDI <code>Instance&lt;T></code> so the
                    behavior is similar except that the injection process is managed by the
                    extension bundle instead of implementation bundle. So the available
                    implementations are searched dynanically into the OSGi service registry.</para>
            </section>
        </section>
        <section>
            <title>OSGi service automatic publishing with <code>@Publish</code> annotation </title>
            <section>
                <title>Simple case</title>
                <para>CDI-OSGi allows developers to automatically publish service implementation.
                    There is nothing to do, just put the annotation. OSGi framework is completely
                    hidden. Then the service is accessible through CDI-OSGi service injection and
                    OSGi classic mechanisms.</para>
                <para>Automatically publish a new service implementation:
                    <programlisting>@Publish
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}</programlisting>It
                    registers a service <code>MyService</code> with the implementation
                        <code>MyServiceImpl</code>. The actual instantiation of
                        <code>MyServiceImpl</code> is transparently delegated to the implementation
                    bundle.</para>
                <para>However, such an implementation also provides a regular CDI managed bean, so
                    MyServiceImpl can also be injected using CDI within the bean bundle.</para>
            </section>
            <section>
                <title>Service type resolution</title>
                <para>When CDI-OSGi publish a service it look for the types the service may be
                    publish with. Here is how CDI-OSGi choose these types: <itemizedlist>
                        <listitem>
                            <para>First CDI-OSGi looks for a contract list provided with the
                                    <code>@Publish</code> annotation. If such a list exists the
                                implementation is published for all the contained types. However the
                                implementation type may be assignable for all the contract types.
                                This is how define a contract
                                list:<programlisting>@Publish(contracts = {
        MyService.class
})
public class MyServiceImpl implements MyService, OtherInterface {
    @Override
    public void doSomething() {
    }
}</programlisting></para>
                        </listitem>
                        <listitem>
                            <para>If there is no contract list provided CDI-OSGi uses the
                                implementation interfaces. The service is register for declaring
                                interface. However CDI-OSGi can apply a filter on the interface list
                                using a blacklist described below.</para>
                        </listitem>
                        <listitem>
                            <para>If CDI-OSGi find neither contract nor non-blacklisted interface it
                                looks for the implementation superclass. The service is register for
                                this superclass except if the superclass is blacklisted.</para>
                        </listitem>
                        <listitem>
                            <para>Last if the implementation has neither contract nor
                                non-blacklisted interface or superclass, the service is register
                                with is own type.</para>
                        </listitem>
                    </itemizedlist></para>
            </section>
            <section>
                <title>Service type blacklist</title>
                <para>TODO</para>
            </section>
        </section>
        <section>
            <title>Clearly specify a service implementation</title>
            <para>There might be multiple implementations of the same service. It is possible to
                qualify specificity of an implementation in CDI-OSGi. This qualification is
                available both during publishing and consuming.</para>
            <para>There are two ways for qualifying: a CDI like and a OSGi like, both are presented
                below.</para>
            <section>
                <title>Using <code>@Qualifier</code> annotations</title>
                <para>Qualifiers are used like in classic CDI applications. An implementation can be
                    qualified by as many qualifiers as needed. An injection point can be also
                    qualified in order to restraint the potential injected implementations. It is
                    finally possible to select the instance produced when using the
                        <code>Service&lt;T></code> interface.</para>
                <para>Qualified service publishing:
                    <programlisting>
@Publish
@AnyQualifier
public class MyServiceQualifiedImpl implements MyService {

    @Override
    public void doSomething() {
    }
}                </programlisting>Qualified
                    injection point:
                    <programlisting>
@Inject @OSGiService @AnyQualifier MyService qualifiedService; 
qualifiedService.doSomething();</programlisting>or
                    with <code>Service&lt;T></code>
                    <programlisting>
@Inject @AnyQualifier Service&lt;MyService> service;
service.get().doSomething();</programlisting></para>
            </section>
            <section>
                <title>Filtering services</title>
                <para>Since CDI-OSGi services stay OSGi services they can be filtered through LDAP
                    filter. Properties might be added at publishing using the <code>Publish</code>
                    annotation values. Then an LDAP filter can be use at injection point using the
                        <code>Filter</code> annotation. </para>
                <para>An example is worth a thousand words:
                    <programlisting>@Publish({
    @Property(name="lang", value="EN"),
    @Property(name="country", value="US")
})
public class MyServiceImpl implements MyService {

    @Override
    public void doSomething() {
    }
}</programlisting>As
                    many <code>@Property</code> annotation as wanted can be added, they are
                    registered with the service implementation.</para>
                <para><code>@Publish</code> annotation is not a qualifier, so it discriminate OSGi
                    service injection points but not regular CDI injection points.</para>
                <para>Then it is possible to filter an injection point with the <code>Filter</code>
                    annotation like a regular LDAP filter:
                    <programlisting>@Inject @Filter("(&amp;(lang=EN)(country=US))") Service&lt;MyService> service;</programlisting>or</para>
                <programlisting>@Inject @Filter("(&amp;(lang=EN)(country=US))") MyService service;</programlisting>
            </section>
            <section>
                <title>Links between qualifier annotations and LDAP filtering</title>
                <para>CDI-OSGi allows you to mix qualifiers and LDAP filter. There are some rules to
                    transform a qualifier to a filter and vice-versa: <itemizedlist>
                        <listitem>
                            <para>A multi-valued qualifier will generate a service property for each
                                of its value. The property has the form [decapitalized qualifier
                                name].[value name]=[value.toString()]:
                                <programlisting>@MyQualifier(lang="EN", country="US")</programlisting>is
                                similar to:
                                <programlisting>@Filter((&amp;(myqualifier.lang=EN)(myqualifier.country=US))</programlisting></para>
                        </listitem>
                        <listitem>
                            <para>A single valued qualifier will generate a service property with
                                the form  [decapitalized qualifier name]=[value.toString()]
                                (discarding the value name):
                                <programlisting>@MyQualifier(lang="EN")</programlisting>is similar
                                to: </para>
                            <programlisting>@Filter((myqualifier=EN))</programlisting>
                        </listitem>
                        <listitem>
                            <para>A non valued qualifier will generate a service property with the
                                form [decapitalized qualifier name]=*:
                                <programlisting>@MyQualifier</programlisting>is similar
                                to:<programlisting>@Filter((myqualifier=*))</programlisting></para>
                        </listitem>
                    </itemizedlist></para>
                <para>CDI-OSGi will look for default value for non specified value before discarding
                    them.</para>
            </section>
            <section>
                <title>Calculating the final filter</title>
                <para>In order to obtain the final LDAP filter for the auto-publishable service or
                    for the service injection point, CDI-OSGi take into account all the qualifier
                    generated filters and the given <code>@Property</code> or <code>@Filter</code>
                    annotations.</para>
            </section>
            <section>
                <title>Filtering after injection</title>
                <para>It is possible to do a programmatic filtering after injection using
                        <code>Service&lt;T></code>:<programlisting>@Inject Service&lt;MyService> services;
services.select(new AnnotationLiteral&lt;AnyQualifier>() {}).get().deSomething();</programlisting>or<programlisting>@Inject Service&lt;MyService> services;
services.select("(&amp;(lang=*)(country=US))").get().deSomething();</programlisting></para>
                <para>However OSGi service may not be subtyped, thus it is not possible to use
                        <code>select()</code> methods with a specified subclass.</para>
            </section>
        </section>
        <section>
            <title>Contextual services</title>
            <para>Like for bean instances, service instances are contextual. Every implementation is
                bounded to a particular scope. Provided that an satisfactory implementation is
                available, a service injection will return a contextual instance of the
                implementation.</para>
            <para>All CDI scopes are available for CDI-OSGi services and their use is the same:
                <programlisting>@Publish
@ApplicationScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}</programlisting>A
                instance will be shared by the entire
                application.<programlisting>@Publish
@RequestScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}                </programlisting>A
                new instance is created for every request.</para>
            <para>If no scope is provided <code>@Dependent</code> is assumed, a new instance will be
                create for every injection.</para>
        </section>
        <section>
            <title>The registration</title>
            <para>A registration object represent all the bindings between a service contract class
                and its OSGi <code>ServiceRegistration</code>s. With this object it is possible to
                navigate through multiple implementations of the same service, obtain the
                corresponding <code>Service&lt;T></code> or unregister these implementations.</para>
            <section>
                <title>registration injection</title>
                <para>A registration is obtained like
                    that:<programlisting>@Inject Registration&lt;MyService> registrations;</programlisting>The
                    injection point can be filtered using
                    qualifiers:<programlisting>@Inject @AnyQualifier Registration&lt;MyService> qualifiedRegistrations;</programlisting>or
                    using LDAP
                    filter:<programlisting>@Inject @Filter("(&amp;(lang=EN)(country=US))") Registration&lt;MyService> qualifiedRegistrations;</programlisting></para>
            </section>
            <section>
                <title>Navigate into registrations and filter them</title>
                <para>It is possible to iterate through
                    registration:<programlisting>if(registrations.size() > 0) {
    for(Registration&lt;T> registration : registrations) {
    }
}</programlisting></para>
                <para>It is also possible to request a subset of the service implementations using
                    qualifiers:<programlisting>Registration&lt;T> filteredRegistrations = registrations.select(new AnnotationLiteral&lt;AnyQualifier>() {});</programlisting>or
                    a LDAP
                    filter:<programlisting>Registration&lt;T> filteredRegistrations = registrations.select("(&amp;(lang=EN)(country=US))");</programlisting>or
                    both:<programlisting>Registration&lt;T> filteredRegistrations = registrations.select(new AnnotationLiteral&lt;AnyQualifier>() {}).select("(&amp;(lang=EN)(country=US))");</programlisting>Link
                    between qualifier and LDAP filter as well as subtyped service selection are
                    explain above in service injection section.</para>
            </section>
            <section>
                <title>Registration usages</title>
                <para>A registration allows to obtain service
                    implementations:<programlisting>Service&lt;T> myServiceImplementations = registrations.getServiceReference();</programlisting>And
                    it allows to unregister service
                    implementations:<programlisting>registrations.unregister();</programlisting></para>
            </section>
        </section>
        <section>
            <title>Service registry</title>
            <para>CDI-OSGi offers another way to deal with services: the service registry. It can be
                obtained in any bundle as a regular service, using OSGi or CDI-OSGi ways. The
                service registry allows developers to dynamically register service implementation,
                to obtain services and registrations.</para>
            <section>
                <title>First get the service registry</title>
                <para>TODO Is the service registry a bean or a service ? If it is a service it could
                    use by regular bundle, couldn't it ?</para>
                <para>First get the service registry:
                    <programlisting>@Inject @OSGiService ServiceRegistry registry;</programlisting>Or
                    in regular bundle:
                    <programlisting>ServiceReference reference = bundleContext.getServiceReference(ServiceRegistry.class.getName());
ServiceRegistry registry = (ServiceRegistry) bundleContext.getService(reference);</programlisting></para>
            </section>
            <section>
                <title>Register a service implementation</title>
                <para>Register a service implementation:
                    <programlisting>registry.registerService(MyService.class,MyServiceImpl.class);</programlisting>
                    or
                    <programlisting>@Inject MyServiceImpl implementation;
registry.registerService(MyService.class,implementation);</programlisting>Here
                    the scope of the service is ??? (Dependent ?)</para>
                <para>It is possible to collect the corresponding registration:
                    <programlisting>Registration&lt;MyService> registeredService = registry.registerService(MyService.class,MyServiceImpl.class);</programlisting></para>
            </section>
            <section>
                <title>Obtain a service implementations</title>
                <para>Obtain a service implementations:
                    <programlisting>Service&lt;MyService> services = registry.getServiceReference(MyService.class);
for (MyService service : services) {
    service.doSomething();
}</programlisting></para>
            </section>
            <section>
                <title>Obtain registrations</title>
                <para>Obtain all registrations of a filtered or not filtered specified service:
                    <programlisting>Registration&lt;?> registrations = registry.getRegistrations();
Registration&lt;MyService> myRegistrations = registry.getRegistrations(MyService.class);
Registration&lt;MyService> myFrenchRegistrations = registry.getRegistrations(MyService.class,"(lang=FR)");     </programlisting></para>
            </section>
        </section>
        <section>
            <title>Distinctions between CDI-OSGi service injection and CDI bean injection</title>
            <para>All the way it is said that CDI-OSGi service injection is similar with classic CDI
                bean injection. That is true, but there some important distinctions to make. CDI
                users will quickly find their bearings in CDI-OSGi and that is the point because CDI
                way is much more simple that OSGi mechanisms (so CDI-OSGi is also a good thing for
                newcomers in both CDI and OSGi worlds! ).</para>
            <para>The main difference is about the dynamism of OSGi services. While a bean injection
                point should be satisfy at the start of the CDI container, service injection may be
                satisfy only at runtime.</para>
            <para>So what ? TODO Ambiguous and unsatisfied dependency management and other stuffs that
                vary from classic CDI.</para>
            <section>
                <title>The <code>OSGiServiceUnavailableException</code> exception </title>
                <para>Because OSGi service are dynamic they might be unavailable at the time they
                    should be used. On a service call if the targeted service isn't available a
                    specific runtime exception is raised:
                    <programlisting>public class OSGiServiceUnavailableException extends RuntimeException {}</programlisting></para>
            </section>
            <section>
                <title>And everything else ?</title>
                <para>If it is not indicated otherwise assume that the comportment is the same as
                    CDI or OSGi without CDI-OSGi.</para>
            </section>
        </section>
    </section>
    <section>
        <title>CDI-OSGi events</title>
        <para>CDI-OSGi makes heavy usage of CDI events. These events allow CDI-OSGi to do its work.
            Events are important for the running of CDI-OSGi itself but they can also be use by
            client bean bundles to perform some operations or override some normal CDI-OSGi
            behavior.</para>
        <para>This section shows the numerous events provided by CDI-OSGi and the ways to use
            them.</para>
        <section>
            <title>CDI container lifecycle events</title>
            <para>Two events inform about the state of the CDI container of every bean bundle:
                    <code>BundleContainerInitialized</code> and <code>BundleContainerShutdown</code>
                events.</para>
            <para>The <code>BundleContext</code> from where the event comes is sent with these
                events so developers can retrieve useful information (such as the bundle owning the
                CDI container).</para>
            <section>
                <title>When the container is started: <code>BundleContainerInitialized</code>
                    event</title>
                <para>The <code>BundleContainerInitialized</code> event is fired every time a CDI
                    container is initialized in a bean bundle. It point out that the CDI container
                    is ready to manage the bean bundle with the CDI-OSGi features.</para>
                <para>Here the way to listen this event:
                    <programlisting>public void onStartup(@Observes BundleContainerInitialized event) {
    BundleContext bundleContext = event.getBundleContext();
    Bundle firingBundle = bundleContext.getBundle();
}</programlisting></para>
            </section>
            <section>
                <title>When the container is stopped: <code>BundleContainerShutdown</code>
                    event</title>
                <para>The <code>BundleContainerShutdown</code> event is fired every time a CDI
                    container is stopped in a bean bundle. It point out that the CDI container wil
                    not manage the bean bundle with CDI-OSGi anymore.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void onShutdown(@Observes BundleContainerShutdown event) {
    BundleContext bundleContext = event.getBundleContext();
    Bundle firingBundle = bundleContext.getBundle();
}</programlisting></para>
            </section>
        </section>
        <section>
            <title>Bundle lifecycle events</title>
            <para>Ten events might be fired during a bundle lifecycle. They represent the possible
                states of a bundle and monitor the changes occurred in bundle lifecycles. These
                events carry the <code>Bundle</code> object from where the event comes so developers
                can retrieve useful information (such as the bundle id).</para>
            <section>
                <title>Listen all bundle events: <code>AbstractBundleEvent</code> event</title>
                <para>CDI-OSGi provides a way to listen all bundle events in a single method: the
                        <code>AbstractBundleEvent</code> abstract class. Every bundle lifecycle
                    event is an <code>AbstractBundleEvent</code> and a method allows to retrieve the
                    actual fired bundle event. All bundle states are listed in the
                        <code>BundleEventType</code> enumeration. Then this event can be used as the
                    corresponding bundle event.</para>
                <para>Here the way to listen all bundle events and to retrieve the corresponding
                    bundle
                    state:<programlisting>public void bundleChanged(@Observes AbstractBundleEvent event) {
    BundleEventType event.getType();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is installed: <code>BundleInstalled</code> event</title>
                <para>An event is fired every time a bundle is install in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void bindBundle(@Observes BundleInstalled event) {
    Bundle bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is uninstalled: <code>BundleUninstalled</code> event</title>
                <para>An event is fired every time a bundle is uninstall from the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void unbindBundle(@Observes BundleUninstalled event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is lazy activated: <code>BundleLazyActivation</code>
                    event</title>
                <para>An event is fired every time a bundle is lazy activated in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void lazyInitBundle(@Observes BundleLazyActivation event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is resolved: <code>BundleResolved</code> event</title>
                <para>An event is fired every time a bundle is resolved in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void resolveBundle(@Observes BundleResolved event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is unresolved: <code>BundleUnresolved</code> event</title>
                <para>An event is fired every time a bundle is unresolved in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void unresolveBundle(@Observes BundleUnresolved event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is updated: <code>BundleUpdated</code> event</title>
                <para>An event is fired every time a bundle is updated in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void updateBundle(@Observes BundleUpdated event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is started: <code>BundleStarted</code> event</title>
                <para>An event is fired every time a bundle is started in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void startBundle(@Observes BundleStarted event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is starting: <code>BundleStarting</code> event</title>
                <para>An event is fired every time a bundle is starting in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void startingBundle(@Observes BundleStarting event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is stopped: <code>BundleStopped</code> event</title>
                <para>An event is fired every time a bundle is stopped in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void stopBundle(@Observes BundleStopped event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>When a bundle is stopping: <code>BundleStopping</code> event</title>
                <para>An event is fired every time a bundle is stopping in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void stoppingBundle(@Observes BundleStopping event) {
    Bunde bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</programlisting></para>
            </section>
            <section>
                <title>Filtering bundle events: <code>BundleName</code> and
                        <code>BundleVersion</code> annotations</title>
                <para>It is possible to filter the listened events depending on the bundles that are
                    concerned. This filter might cover the name or the version of the
                    bundles.</para>
                <para>Here the way to filter bundle events on the bundle
                    names:<programlisting>public void bindBundle(@Observes @BundleName("com.sample.gui") BundleInstalled event) {
}</programlisting>or
                    on the bundle
                    versions:<programlisting>public void bindBundle(@Observes @BundleVersion("4.2.1") BundleInstalled event) {
}</programlisting>or
                    on both bundle names and
                    versions:<programlisting>public void bindBundle(@Observes @BundleName("com.sample.gui") @BundleVersion("4.2.1") BundleInstalled event) {
}</programlisting></para>
            </section>
        </section>
        <section>
            <title>Service lifecyle events</title>
            <para>Three events might be fired during a service lifecycle. They represent the
                possible states of a service and monitor the changes occurred in service lifecycles.
                These events carry the <code>BundleContext</code> object from where the event comes
                and the <code>ServiceReference</code> object correspondign to the service so
                developers can retrieve useful information (such as the registering bundle) and
                acces useful actions (such as register or unregister services).</para>
            <section>
                <title>Listen all service events: <code>AbstractServiceEvent</code> event</title>
                <para>CDI-OSGi provides a way to listen all service events in a single method: the
                        <code>AbstractServiceEvent</code> abstract class. Every service lifecycle
                    event is an <code>AbstractServiceEvent</code> and a method allows to retrieve
                    the actual fired service event. All service states are listed in the
                        <code>ServiceEventType</code> enumeration. Then this event can be used as
                    the corresponding service event.</para>
                <para>Here the way to listen all service events and to retrieve the corresponding
                    service
                    state:<programlisting>public void serviceEvent(@Observes AbstractServiceEvent event) {
    ServiceEventType event.getType();
}</programlisting></para>
            </section>
            <section>
                <title>When a service is published: <code>ServiceArrival</code> event</title>
                <para>An event is fired every time a service is published in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void bindService(@Observes ServiceArrival event) {
    ServiceReference serviceReference = event.getRef();
    Bundle registeringBundle = event.getRegisteringBundle();
}</programlisting></para>
            </section>
            <section>
                <title>When a service is unpublished: <code>ServiceDeparture</code> event</title>
                <para>An event is fired every time a service is unpublished in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void unbindService(@Observes ServiceDeparture event) {
    ServiceReference serviceReference = event.getRef();
    Bundle registeringBundle = event.getRegisteringBundle();
}</programlisting></para>
            </section>
            <section>
                <title>When a service is changed: <code>ServiceChange</code> event</title>
                <para>An event is fired every time a service is changed in the OSGi
                    environment.</para>
                <para>Here the way to listen this
                    event:<programlisting>public void changeService(@Observes ServiceChange event) {
    ServiceReference serviceReference = event.getRef();
    Bundle registeringBundle = event.getRegisteringBundle();
}</programlisting></para>
            </section>
            <section>
                <title>Filtering service events: <code>Specification</code> and <code>Filter</code>
                    annotations</title>
                <para>It is possible to filter the listened events depending on the services that
                    are concerned. This filter might cover the service specification class or it
                    might be a LDAP filter.</para>
                <para>Here the way to filter service events on the specification
                    class:<programlisting>public void bindService(@Observes @Specification(MyService.class) ServiceArrival event) {
}</programlisting>or
                    using a LDAP
                    filter:<programlisting>public void bindService(@Observes @Specification(MyService.class) ServiceArrival event) {
}</programlisting>or
                    on both specification class and LDAP
                    filter:<programlisting>public void bindService(@Observes @Specification(MyService.class) @Filter("(&amp;(lang=EN)(country=US))") ServiceArrival event) {
}</programlisting></para>
            </section>
        </section>
        <section>
            <title>Application dependency validation events</title>
            <para>Some bean bundle might declare required dependencies on services (using the
                    <code>Required</code> annotation). CDI-OSGi fired events when these required
                dependencies are all validated or when at least one is invalidated. It allows
                application to be automatically started or stopped.</para>
            <section>
                <title>When all dependencies are validated: <code>Valid</code> event</title>
                <para>An event is fired every time all the required dependencies are
                    validated.</para>
                <para>Here the way to listen this event:
                    <programlisting>public void validate(@Observes Valid event) {
}</programlisting></para>
            </section>
            <section>
                <title>When at least one dependency is invalidated: <code>Invalid</code>
                    event</title>
                <para>An event is fired every time at least one of the required dependencies is
                    invalidated.</para>
                <para>Here the way to listen this event:
                    <programlisting>public void invalidate(@Observes Invalid event) {
}</programlisting></para>
            </section>
        </section>
        <section>
            <title>Intra and inter bundles communication events</title>
            <para>CDI-OSGi provides a way to communicate within and between bean bundles. This
                communication occurs in a totally decoupled manner using CDI events.</para>
            <section>
                <title>Firing a bundle communication event: <code>InterBundleEvent</code>
                    event</title>
                <para>An <code>InterBundleEvent</code> is a message containing a object and
                    transmited using CDI event.</para>
                <para>Here the way to fire such an
                    event:<programlisting>@Inject Event&lt;InterBundleEvent> event;
MyMessage myMessage = new MyMessage();
event.fire(new InterBundleEvent(myMessage));</programlisting></para>
            </section>
            <section>
                <title>When a bundle communication is received: <code>InterBundleEvent</code>
                    event</title>
                <para>When an <code>InterBundleEvent</code> is fired it might be catch either within
                    the bundle or in other bundles or both.</para>
                <para>Here the way to receive a communication event from within the
                    bundle:<programlisting>public void listenAllEvents(@Observes InterBundleEvent event) {
}</programlisting></para>
                <para>Here the way to receive a communication event from another
                    bundles:<programlisting>public void listenAllEventsFromOtherBundles(@Observes @Sent InterBundleEvent event) {
}</programlisting></para>
            </section>
            <section>
                <title>Filtering communication events: <code>Specification</code> annotation</title>
                <para>It is possible to filter the listened events depending on the message type.
                    This filter may specify the type of message that is listened.</para>
                <para>Here the way to filter communication events specifying a message type:
                    <programlisting>public void listenStringEventsFromOtherBundles(@Observes @Sent @Specification(MyMessage.class) InterBundleEventevent) {
}</programlisting>Only
                    the message with type <code>MyMessage</code> will be received.</para>
            </section>
        </section>
    </section>
    <section>
        <title>OSGi utilities</title>
        <para>CDI-OSGi provide some facilities for OSGi usage. It allows to obtain, by injection,
            some of the useful objects of the OSGi environment.</para>
        <section>
            <title>From the current bundle</title>
            <para>Here a way to obtain the current
                bundle:<programlisting>@Inject Bundle bundle;</programlisting></para>
            <para>Here a way to obtain the current bundle
                context:<programlisting>@Inject BundleContext bundleContext;</programlisting></para>
            <para>Here a way to obtain all the current bundle
                headers:<programlisting>@Inject @BundleHeaders Map&lt;String,String>metadata;</programlisting>or
                a particular
                header<programlisting>@Inject @BundleHeader("Bundle-SymbolicName") String symbolicName;</programlisting></para>
            <para>Here a way to obtain a resource file from the current
                bundle:<programlisting>@Injec @BundleDataFile("test.txt") File file;</programlisting></para>
        </section>
        <section>
            <title>From external bundle</title>
            <para>Here a way to obtain a specified bundle from its name and
                version:<programlisting>@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") bundle;</programlisting>or
                just from its
                name:<programlisting>@Inject @BundleName("com.sample.gui") bundle;</programlisting></para>
            <para>Here a way to obtain all the specified bundle
                headers:<programlisting>@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") @BundleHeaders Map&lt;String,String>metadata;</programlisting>or
                a particular
                header:<programlisting>@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") @BundleHeader("Bundle-SymbolicName") String symbolicName;</programlisting></para>
        </section>
    </section>
    <section>
        <title>An OSGi extension for CDI support: the extension API</title>
        <section>
            <title>CDI-OSGi features</title>
            <para>We will see in the next sections these features in deep through the description of
                the extension API.</para>
        </section>
        <section>
            <title>The interfaces</title>
            <para>Extension API provides few interfaces that describe all specifics about OSGi
                service injection.</para>
            <section>
                <title>The <code>Service</code> interface</title>
                <programlisting>public interface Service&lt;T> extends Iterable&lt;T> {

    T get();    
    Service&lt;T> select(Annotation... qualifiers);
    Service&lt;T> select(String filter);
    boolean isUnsatisfied();
    boolean isAmbiguous();
    int size();
}</programlisting>
                <para>It represents a service instance producer parametrized by the service to
                    inject. It has the same behavior than CDI <code>Instance&lt;T></code> except
                    that it represents only OSGi service beans.</para>
                <para>IT allows to:<itemizedlist>
                        <listitem>
                            <para>Wrap a list of potential service implementations as an
                                    <code>Iterable</code> java object,</para>
                        </listitem>
                        <listitem>
                            <para>Select a subset of these service implementations filtered by
                                    <code>Qualifier</code>s or LDAP filters,</para>
                        </listitem>
                        <listitem>
                            <para>Iterate through these service implementations,</para>
                        </listitem>
                        <listitem>
                            <para>Obtain an instance of the first remaining service
                                implementations,</para>
                        </listitem>
                        <listitem>
                            <para>Obtain utility information about the contained service
                                implementations.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>OSGi services should not be subtyped.</para>
            </section>
            <section>
                <title>The <code>Registration</code> interface</title>
                <programlisting>public interface Registration&lt;T> extends Iterable&lt;Registration&lt;T>> {

    void unregister();
    &lt;T> Service&lt;T> getServiceReference();
    Registration&lt;T> select(Annotation... qualifiers);
    Registration&lt;T> select(String filter);
    int size();
}
            </programlisting>
                <para>This interface represents the registrations of an injectable service in the
                    service registry. Its behavior is similar to <code>Service&lt;T></code>, thus it
                    might represent the iterable set of all the registrations of a service.</para>
                <para>It allows to:<itemizedlist>
                        <listitem>
                            <para>Wrap a list of service registration (i.e. the bindings between a
                                service and its implementations) as an <code>Iterable</code> java
                                object,</para>
                        </listitem>
                        <listitem>
                            <para>Select a subset of these registration filtered by
                                    <code>Qualifier</code>s or LDAP filters,</para>
                        </listitem>
                        <listitem>
                            <para>Iterate through these service registrations,</para>
                        </listitem>
                        <listitem>
                            <para>Obtain the service implementations list as a
                                    <code>Service&lt;T></code>,</para>
                        </listitem>
                        <listitem>
                            <para>Get the number of registrations (i.e the number of registered
                                service implementations).</para>
                        </listitem>
                    </itemizedlist></para>
                <para>OSGi services should not be subtyped.</para>
            </section>
            <section>
                <title>The <code>RegistrationHolder</code> interface</title>
                <para>
                    <programlisting>public interface RegistrationHolder {

    List&lt;ServiceRegistration> getRegistrations();
    void addRegistration(ServiceRegistration reg);
    void removeRegistration(ServiceRegistration reg);
    void clear();
    int size();
}</programlisting>
                </para>
                <para>This interface represents the bindings between a service and its registered
                    implementations. It is used by <code>Registration</code> to maintain the list of
                    registration bindings. It uses OSGi <code>ServiceRegistration</code>.</para>
                <para>It allows to:<itemizedlist>
                        <listitem>
                            <para>Wrap a list of <code>ServiceRegistration</code> as binding between
                                a service and its implementations as a <code>List</code>,</para>
                        </listitem>
                        <listitem>
                            <para>Handle this list with addition, removal, clearing and size
                                operations.</para>
                        </listitem>
                    </itemizedlist></para>
            </section>
            <section>
                <title>The <code>ServiceRegistry</code> interface</title>
                <programlisting>public interface ServiceRegistry {

    &lt;T> Registration&lt;T> registerService(Class&lt;T> contract, Class&lt;? extends T> implementation);
    &lt;T, U extends T> Registration&lt;T> registerService(Class&lt;T> contract, U implementation);
    &lt;T> Service&lt;T> getServiceReferences(Class&lt;T> contract);
}</programlisting>
                <para>This interface represents a service registry where all OSGi services may be
                    handled.</para>
                <para>It allows to:<itemizedlist>
                        <listitem>
                            <para>Register a service implementation with a service, getting back the
                                corresponding <code>Registration</code>,</para>
                        </listitem>
                        <listitem>
                            <para>Obtain the service implementations list as a
                                    <code>Service&lt;T></code>.</para>
                        </listitem>
                    </itemizedlist></para>
            </section>
        </section>
        <section>
            <title>The events</title>
            <para>Extension API provides numerous events that notify about life-cycle steps for CDI
                container management, service management, bundle management, bean bundle validation
                and bundle communication management. They all use CDI event system.</para>
            <para>CDI container events, as well as service and bundle events, are regroupped using
                three classes. Thus each category of event has: <itemizedlist>
                    <listitem>
                        <para>An abstract class representing all the events of this category,
                            defining the global comportment and allowing to handle all the lifecycle
                            steps in one operation,</para>
                    </listitem>
                    <listitem>
                        <para>An enumeration describing the list of possible event types, allowing
                            to discriminate a particular lifecycle step of the category,</para>
                    </listitem>
                    <listitem>
                        <para>A list of implementation class for each of the above type, allowing to
                            handle a particular lifecycle step only. These implementation classes
                            are regroupped as static inner classes of a global category event
                            class.</para>
                    </listitem>
                </itemizedlist></para>
            <section>
                <title>The bundle events</title>
                <para>The representing abstract class:
                    <programlisting>public abstract class AbstractBundleEvent {

    private final Bundle bundle;

    public AbstractBundleEvent(Bundle bundle) {...}
    
    public abstract BundleEventType getType();
    public long getBundleId() {...}
    public String getSymbolicName() {...}
    public Version getVersion() {...}
    public Bundle getBundle() {...}
}</programlisting></para>
                <para>This abstract class represents all the CDI-OSGi bundle events as a
                    superclass.</para>
                <para>It allows to:<itemizedlist>
                        <listitem>
                            <para>Represent all bundle events,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the current event type as a
                                <code>BundleEventType</code>,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the firing bundle and its information.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>It may be used in <code>Observes</code> method in order to listen all bundle
                    events.</para>
                <para>The possible event types:
                    <programlisting>public enum BundleEventType {

    INSTALLED,
    LAZY_ACTIVATION,
    RESOLVED,
    STARTED,
    STARTING,
    STOPPED,
    STOPPING,
    UNINSTALLED,
    UNRESOLVED,
    UPDATED,
}</programlisting></para>
                <para>This enumeration lists all possible states of a bundle and the corresponding
                    event types.</para>
                <para>The implementation classes (in the global event class):
                    <programlisting>public class BundleEvents {

    public static class BundleInstalled extends AbstractBundleEvent {

        public BundleInstalled(Bundle bundle) {...}

        @Override
        public BundleEventType getType() {...}
    }
    //next classes follow the same template as above
    public static class BundleLazyActivation extends AbstractBundleEvent {...}
    public static class BundleResolved extends AbstractBundleEvent {...}
    public static class BundleStarted extends AbstractBundleEvent {...}
    public static class BundleStarting extends AbstractBundleEvent {...}
    public static class BundleStopped extends AbstractBundleEvent {...}
    public static class BundleStopping extends AbstractBundleEvent {...}
    public static class BundleUninstalled extends AbstractBundleEvent {...}
    public static class BundleUnresolved extends AbstractBundleEvent {...}
    public static class BundleUpdated extends AbstractBundleEvent {...}
}</programlisting></para>
                <para>This class wraps all the bundle events as inner static classes. There is one
                    event class by <code>BundleEventType</code>.</para>
                <para>Each inner class allows to:<itemizedlist>
                        <listitem>
                            <para>Represent a specific bundle event,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the same information as
                                <code>AbstractBundleEvent</code>.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>They may be used in <code>Observes</code> method in order to listen a specific
                    bundle event.</para>
            </section>
            <section>
                <title>The service events</title>
                <para>The representing abstract class:
                    <programlisting>public abstract class AbstractServiceEvent {

    private final ServiceReference reference;
    private final BundleContext context;
    private List&lt;String> classesNames;
    private List&lt;Class&lt;?>> classes;
    private Map&lt;Class, Boolean> assignable;

    public AbstractServiceEvent(ServiceReference reference, BundleContext context) {...}
    
    public abstract ServiceEventType eventType();
    public ServiceReference getReference() {...}
    public &lt;T> TypedService&lt;T> type(Class&lt;T> type) {...}
    public Object getService() {...}
    public boolean ungetService() {...}
    public boolean isTyped(Class&lt;?> type) {...}
    public Bundle getRegisteringBundle() {...}
    public List&lt;String> getServiceClassNames() {...}
    public List&lt;Class&lt;?>> getServiceClasses() {...}

    public static class TypedService&lt;T> {

        private final BundleContext context;
        private final ServiceReference ref;
        private final Class&lt;T> type;

        TypedService(BundleContext context, ServiceReference ref, Class&lt;T> type) {...}
        
        static &lt;T> TypedService&lt;T> create(Class&lt;T> type, BundleContext context, ServiceReference ref) {...}
        public T getService() {...}
        public boolean ungetService() {...}
    }
}</programlisting></para>
                <para>This abstract class represents all the CDI-OSGi service events as a
                    superclass.</para>
                <para>It allows to:<itemizedlist>
                        <listitem>
                            <para>Represent all service events,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the current event type as a
                                <code>ServiceEventType</code>,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the affected <code>ServiceReference</code>, the
                                corresponding information and registering
                                <code>Bundle</code>,</para>
                        </listitem>
                        <listitem>
                            <para>Manipulate the service,</para>
                        </listitem>
                        <listitem>
                            <para>Retreive the firing <code>BundleContext</code>.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>It may be used in <code>Observes</code> method in order to listen all service
                    events.</para>
                <para>The possible event types:
                    <programlisting>public enum ServiceEventType {

    SERVICE_ARRIVAL,
    SERVICE_DEPARTURE,
    SERVICE_CHANGED
}</programlisting></para>
                <para>This enumeration lists all possible states of a service and the corresponding
                    event types.</para>
                <para>The implementation classes (in the global event class):
                    <programlisting>public class ServiceEvents {

    public static class ServiceArrival extends AbstractServiceEvent {

        public ServiceArrival(
                ServiceReference ref, BundleContext context) {
            super(ref, context);
        }

        @Override
        public ServiceEventType eventType() {
            return ServiceEventType.SERVICE_ARRIVAL;
        }
    }
    //next classes follow the same template as above
    public static class ServiceChanged extends AbstractServiceEvent {...}
    public static class ServiceDeparture extends AbstractServiceEvent {...}

}</programlisting></para>
                <para>This class wraps all the service events as inner static classes. There is one
                    event class by <code>ServiceEventType</code>.</para>
                <para>Each inner class allows to:<itemizedlist>
                        <listitem>
                            <para>Represent a specific service event,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the same information as
                                <code>AbstractServiceEvent</code>.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>They may be used in <code>Observes</code> method in order to listen a specific
                    service event.</para>
            </section>
            <section>
                <title>The bundle container events</title>
                <para>The representing abstract class:
                    <programlisting>public abstract class AbstractBundleContainerEvent {

    private BundleContext bundleContext;

    public AbstractBundleContainerEvent(final BundleContext context) {...}

    public BundleContext getBundleContext() {...}
    public abstract BundleContainerEventType getType();
}</programlisting></para>
                <para>This abstract class represents all the CDI-OSGi bundle container events as a
                    superclass.</para>
                <para>It allows to:<itemizedlist>
                        <listitem>
                            <para>Represent all bundle container events,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the current event type as a
                                    <code>BundleContainerEventType</code>,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the firing <code>BundleContext</code>.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>It may be used in <code>Observes</code> method in order to listen all bundle
                    container events.</para>
                <para>The possible event types:
                    <programlisting>public enum BundleContainerEventType {

    INITIALIZED,
    SHUTDOWN
}</programlisting></para>
                <para>This enumeration list all possible states of a bundle container and the
                    corresponding event types.</para>
                <para>The implementation classes (in the global event class):
                    <programlisting>public class BundleContainerEvents {

    public static class BundleContainerInitialized extends AbstractBundleContainerEvent {

        public BundleContainerInitialized(BundleContext context) {
            super(context);
        }

        @Override
        public BundleContainerEventType getType() {
            return BundleContainerEventType.INITIALIZED;
        }
    }
    //next class follows the same template as above
    public static class BundleContainerShutdown extends AbstractBundleContainerEvent {...}
}</programlisting></para>
                <para>This class wraps all the bundle container events as inner static classes.
                    There is one event class by <code>BundleContainerEventType</code>.</para>
                <para>Each inner class allows to:<itemizedlist>
                        <listitem>
                            <para>Represent a specific bundle container event,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the same information as
                                    <code>AbstractBundleContainerEvent</code>.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>They may be used in <code>Observes</code> method in order to listen a specific
                    bundle container event.</para>
            </section>
            <section>
                <title>The bean bundle validation events</title>
                <para>Two events notify about the validation of bean bundle. After it starts a bean
                    bundle should validate its required service dependencies. The <code>Valid</code>
                    and <code>Invalid</code> events occurs when such dependencies are fulfilled or
                    unfulfilled. These two new states are described in an enumaration:
                        <code>BundleState</code>.</para>
                <para>
                    <programlisting>public class Valid {

    private final Bundle bundle;

    public Valid(Bundle bundle) {...}

    public long getBundleId() {...}
    public String getSymbolicName() {...}
    public Version getVersion() {...}
    public Bundle getBundle() {...}
}</programlisting>
                </para>
                <para>This class represents all bean bundle validation event.</para>
                <para>It allows to:<itemizedlist>
                        <listitem>
                            <para>Represent all bean bundle validation events,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the validated bean bundle and its information.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>It may be used in <code>Observes</code> method in order to listen all bean
                    bundle validation events.</para>
                <para>
                    <programlisting>public class Invalid {

    private final Bundle bundle;

    public Invalid(Bundle bundle) {...}

    public long getBundleId() {...}
    public String getSymbolicName() {...}
    public Version getVersion() {...}
    public Bundle getBundle() {...}
}</programlisting>
                </para>
                <para>This class represents all bean bundle invalidation event.</para>
                <para>It allows to:<itemizedlist>
                        <listitem>
                            <para>Represent all bean bundle invalidation events,</para>
                        </listitem>
                        <listitem>
                            <para>Retrieve the invalidated bean bundle and its information.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>It may be used in <code>Observes</code> method in order to listen all bean
                    bundle invalidation events.</para>
                <programlisting>public enum BundleState {
    VALID, INVALID
}</programlisting>
                <para>This enumeration lists the two new states of a bean bundle.</para>
                <para>A bean bundle is in <code>VALID</code> state if all its required service
                    dependencies are validated otherwise is in <code>INVALID</code> state. Every
                    time a bean bundle goes from one state to another a corresponding
                        <code>Valid</code> or <code>Invalid</code> event may be fired.</para>
            </section>
            <section>
                <title>The <code>InterBundleEvent</code> event</title>
                <para>
                    <programlisting>public class InterBundleEvent {

    private final Object event;
    private boolean sent = false;
    private Class&lt;?> type;

    public InterBundleEvent(Object event) {...}
    public InterBundleEvent(Object event, Class&lt;?> type) {...}

    public Class&lt;?> type() {...}
    public boolean isTyped(Class&lt;?> type) {...}
    public &lt;T> Provider&lt;T> typed(Class&lt;T> type) {...}
    public Object get() {...}
    public boolean isSent() {...}
    public void sent() {...}
}</programlisting>
                </para>
                <para>This class represents a communication event between bean bundles.</para>
                <para>It allows to specify: <itemizedlist>
                        <listitem>
                            <para>The message as an <code>Object</code>,</para>
                        </listitem>
                        <listitem>
                            <para>The type of the message as a <code>Class</code>,</para>
                        </listitem>
                        <listitem>
                            <para>The origin of the message (within or outside the bundle).</para>
                        </listitem>
                    </itemizedlist></para>
                <para>It may be used in <code>Observes</code> method in order to listen inter-bundle
                    communications.</para>
            </section>
        </section>
        <section>
            <title>The annotations</title>
            <para>Extension API provides annotations in order to easily use CDI-OSGi
                features.</para>
            <section>
                <title>The <code>OSGiBundle</code>, <code>BundleName</code> and
                        <code>BundleVersion</code> annotations</title>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface OSGiBundle {
    @Nonbinding String value();
    @Nonbinding String version() default "";
}</programlisting>
                <para>This annotation qualifies an injection point that represents a bundle or a
                    bundle relative object.</para>
                <para>It allows to specify:<itemizedlist>
                        <listitem>
                            <para>The symbolic name of the bundle, as a required value,</para>
                        </listitem>
                        <listitem>
                            <para>The version of the bundle, as an optional value.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>The symbolic name and version are <emphasis role="bold">not</emphasis>
                    actually qualifying the injection point, thus this annotation is for global
                    bundle injection point with additional data. In order to actually discriminate
                    on the symbolic name or version see <code>BundleName</code> and
                        <code>BundleVersion</code> annotations.</para>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleName {
    String value();
}</programlisting>
                <para>This annotation qualifies an injection point that represents a bundle or a
                    bundle relative object.</para>
                <para>It allows to specify the symbolic name of the bundle, as a required
                    value.</para>
                <para>The symbolic name actually discriminate the injection point, thus this
                    annotation is for specific bundle relative injection point. For global bundle
                    relative injection point see <code>OSGiBundle</code> annotation. To discriminate
                    the bundle version see <code>BundleVersion</code>.</para>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleVersion {
    String value();
}</programlisting>
                <para>This annotation qualifies an injection point that represents a bundle or a
                    bundle relative object.</para>
                <para>It allows to specify the version of the bundle, as a required value.</para>
                <para>The version actually discriminate the injection point, thus this annotation is
                    for specific bundle relative injection point. For global bundle relative
                    injection point see <code>OSGiBundle</code> annotation. To discriminate the
                    bundle symbolic name see <code>BundleName</code>.</para>
            </section>
            <section>
                <title>The <code>BundleDataFile</code>, <code>BundleHeader</code> and
                        <code>BundleHeaders</code> annotations</title>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleDataFile {
    @Nonbinding String value();
}</programlisting>
                <para>This annotation qualifies an injection point that represents a bundle data
                    file.</para>
                <para>It allows to specify the relative path of the file in the bundle, as a
                    required value.</para>
                <para>The file path is <emphasis role="bold">not</emphasis> actually qualifying the
                    injection point, thus this annotation is for global bundle data file injection
                    point with additional data. To discriminate the bundle use
                        <code>OSGiBundle</code> or <code>BundleName</code> and
                        <code>BundleVersion</code> annotations.</para>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleHeader {
    @Nonbinding String value();
}</programlisting>
                <para>This annotation qualifies an injection point that represents a specific bundle
                    header.</para>
                <para>It allows to specify the name of the bundle header, as a required
                    value.</para>
                <para>The header name is <emphasis role="bold">not</emphasis> actually qualifying
                    the injection point, thus this annotation is for global specific bundle header
                    injection point with additional data. To discriminate the bundle use
                        <code>OSGiBundle</code> or <code>BundleName</code> and
                        <code>BundleVersion</code> annotations. To obtain all the bundle headers see
                        <code>BundleHeaders</code> annotations.</para>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleHeaders {
}</programlisting>
                <para>This annotation qualifies an injection point that represents all headers of a
                    bundle.</para>
                <para>To discriminate the bundle use <code>OSGiBundle</code> or
                        <code>BundleName</code> and <code>BundleVersion</code> annotations. To
                    obtain a specific bundle header see <code>BundleHeader</code> annotation.</para>
            </section>
            <section>
                <title>The <code>OSGiService</code> annotation</title>
                <programlisting>@Qualifier
@Target({ TYPE, METHOD, PARAMETER, FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface OSGiService {
}</programlisting>
                <para>This annotation qualifies an injection point that represents a service from
                    the OSGi service registry.</para>
                <para>It may be use to obtain an injected OSGi service using <code>Service</code>
                    interface or directly the service contract interface. The injected service might
                    be filtered using regular <code>Qualifer</code> annotations or a LDAP filter
                    with <code>Filter</code> annotation. It also might be mark as required for
                    bundle running using <code>Required</code> annotation.</para>
            </section>
            <section>
                <title>The <code>Publish</code> and <code>Property</code> annotations</title>
                <programlisting>@Target({ TYPE })
@Retention(RetentionPolicy.RUNTIME)
public @interface Publish {
    public Class[] contracts() default {};
    public Property[] properties() default {};
    public boolean useQualifiersAsProperties() default true;
}</programlisting>
                <para>This annotation notices that this type is an OSGi service implementation and
                    should be automatically published in the OSGi service registry.</para>
                <para>It allows to specify:<itemizedlist>
                        <listitem>
                            <para>The contract interfaces of implemented service, as an optional
                                array of <code>Class</code>es,</para>
                        </listitem>
                        <listitem>
                            <para>The properties of the published service implementation, as an
                                optional array of <code>Property</code>,</para>
                        </listitem>
                        <listitem>
                            <para>If <code>Qualifier</code> annotations are considered as properties
                                or not, as an optional <code>Boolean</code>.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>The published implementation might be discriminated using regular
                        <code>Qualifer</code> annotations or a LDAP filter with <code>Filter</code>
                    annotation.</para>
                <para>
                    <programlisting>@Retention(RetentionPolicy.RUNTIME)
public @interface Property {
    String name();
    String value();
}</programlisting>
                </para>
                <para>This annotation wraps an OSGi service property used for automatic OSGi service
                    publishing.</para>
                <para>It allows to specify:<itemizedlist>
                        <listitem>
                            <para>The name of the property, as a required
                                <code>String</code>,</para>
                        </listitem>
                        <listitem>
                            <para>The value of the property, as a required
                                <code>String</code>.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>It may be used within the <code>Publish</code> annotation to provide the
                    published service implementation properties.</para>
            </section>
            <section>
                <title>The <code>Required</code> annotation</title>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface Required {
}</programlisting>
                <para>This annotation qualifies an injection point that represents a required
                    service.</para>
                <para>It may be coupled with the <code>OSGiService</code> annotation in order to
                    qualify a service that must be available for the application to start.</para>
            </section>
            <section>
                <title>The <code>Filter</code> annotation</title>
                <programlisting>@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface Filter {
    String value();
}</programlisting>
                <para>This annotation qualifies an injection point that represents a LDAP filtered
                    service.</para>
                <para>It allows to specify the LDAP filter, as a required
                    <code>String</code>.</para>
                <para>It may be coupled with a <code>OSGiService</code> or a <code>Publish</code>
                    annotation in order to filter the injected or published service implementations.
                    The LDAP filtering acts on <code>Qualifier</code> or <code>Property</code>
                    annotations or regular OSGi properties used in service publishing.</para>
            </section>
            <section>
                <title>The <code>Specification</code> annotation</title>
                <programlisting>@Qualifier
@Target({ PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Specification {
    Class value();
}</programlisting>
                <para>This annotation qualifies an injection point that represents events whose
                    match one of the specifications.</para>
                <para>It allows to specify the specification interfaces of the <code>Event</code>s
                    parametrizing types, as a required <code>Class</code>.</para>
                <para>It may be used in an <code>Observes</code> method to restrict the listened
                    events.</para>
            </section>
            <section>
                <title>The <code>Sent</code> annotation</title>
                <programlisting>@Qualifier
@Target({ PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Sent {
}</programlisting>
                <para>This annotation qualifies an injection point that represents an
                        <code>InterBundleEvent</code> from outside the current
                    <code>Bundle</code>.</para>
                <para>It may be used in an <code>Observes</code> method to restrict the listened
                        <code>InterBundleEvent</code>. It allows to ignore the
                        <code>InterBundleEvent</code> from within the current bundle.</para>
            </section>
        </section>
    </section>
    <section>
        <title>A standard bootstrap for CDI container integration: the integration API</title>
        <section>
            <title>Why an integration API</title>
            <para>CDI-OSGi could have been carried out with an internal CDI compliant container and
                work very well. Every one of the specifications above would have been fulfilled. But
                no other specific utilities or CDI evolution could have been added without a
                complete modification of CDI-OSGi.</para>
            <para>Then there is the integration API. With that, developers are able to provide their
                own integration bundle. Thus it is possible to use any CDI compliant container with
                a CDI-OSGi application or mix up different CDI compliant containers for different
                bundles.</para>
            <para>Integration API describes what needs the extension bundle to work (and therefore
                what may provide the integraton bundle).</para>
            <section>
                <title>The <code>CDIContainer</code> interface</title>
                <programlisting>public interface CDIContainer {

    boolean initialize();

    boolean shutdown();

    boolean isStarted();

    void fire(InterBundleEvent event);

    Bundle getBundle();

    BeanManager getBeanManager();

    Event getEvent();

    Instance&lt;Object> getInstance();

    Collection&lt;String> getBeanClasses();

    Collection&lt;ServiceRegistration> getRegistrations();

    void setRegistrations(Collection&lt;ServiceRegistration> registrations);

}</programlisting>
                <para/>
            </section>
            <section>
                <title>The <code>BundleContainerFactory</code> interface</title>
                <programlisting>public interface BundleContainerFactory {

    Class&lt;? extends BundleContainerFactory> delegateClass();
    String getID();
    Set&lt;String> getContractBlacklist()
    BundleContainer container(Bundle bundle);
}</programlisting>
                <para>This the how the extension bundle require a CDI compliant container from the
                    implementation bundle. This latter should publish an OSGi service that complies
                    with this interface.</para>
            </section>
        </section>
        <section>
            <title>Embedded mode</title>
            <para>TODO How does it work ? Should we provide something ? Should business bundles use
                the integration API ? A template activator ?</para>
        </section>
        <section>
            <title>Integration bundle discovery and CDI-OSGi start</title>
            <figure>
                <title>CDI-OSGi framework start and stop protocol</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/CDI-OSGistartprotocol.png" format="PNG"
                            align="center" width="800" depth="600"/>
                    </imageobject>
                    <caption>This figure shows the steps of the CDI-OSGi starting and stopping
                        protocol. Between step 8 and step 11 the framework is in stable state and
                        manages bean bundles.</caption>
                </mediaobject>
            </figure>
        </section>
    </section>
    <section>
        <title>An orchestrator : the extension bundle TODO</title>
        <section>
            <title>The extender pattern</title>
            <para>CDI-OSGi provides an extension to OSGi as an extender pattern. The extension
                bundle, the extender, tracks for bean bundles, the extensions, to be started. Then
                CDI utilities are enabled for these bean bundles over OSGi environment.</para>
        </section>
        <section>
            <title>The extension bundle works that way:</title>
            <para>
                <programlisting>BEGIN
    start
    WHILE ! implementation_bundle.isStarted
        wait
    END_WHILE
    obtain_container_factory
    FOR bean_bundle : started_bundles
        manage_bean_bundle
        provide_container
    END_FOR
    WHILE implementation_bundle.isStarted
        wait_event
        OnBeanBundleStart
            manage_bean_bundle
            provide_container
        OnBeanBundleStop
            unmanage_bean_bundle
    END_WHILE
    stop
    FOR bean_bundle : namaged_bundles
        unmanage_bean_bundle
        stop_bean_bundle
    END_FOR
END</programlisting>
            </para>
        </section>
    </section>
    <section>
        <title>A interchangeable CDI container factory: the implementation bundle TODO</title>
        <para>The implementation bundle is is necessary in a CDI-OSGi application. This section
            explains the part the implementation bundle plays but does not enter in specifics
            because it depends on the CDI vendor implementation used.</para>
        <para>Weld-OSGi chapter presents how an implementation bundle can work.</para>
        <section>
            <title>A implementation bundle may work that way:</title>
            <para>
                <programlisting>BEGIN
    start
    register_container_factory_service
    WHILE true
        wait
        OnContainerRequest
            provide_container
    END_WHILE
    unregister_container_factory_service
END</programlisting>
            </para>
        </section>
    </section>
</chapter>
